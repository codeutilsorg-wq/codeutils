<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free Favicon Generator | Gradient Backgrounds, Custom Fonts & All Sizes - Code Utils</title>
    <meta name="description"
        content="Free favicon generator with gradient backgrounds, 10 fonts, and 9 sizes (16-512px). Text, emoji & image support. Hexagon shapes, platform previews. Download ZIP/ICO. 100% private.">
    <link rel="canonical" href="https://codeutils.org/favicon-generator">

    <!-- Favicon and Touch Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#3498db">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://codeutils.org/favicon-generator">
    <meta property="og:title" content="Free Favicon Generator - Code Utils">
    <meta property="og:description"
        content="Create favicons from text, emoji, or images. Generate multiple sizes instantly. 100% private client-side processing.">
    <meta property="og:image" content="https://codeutils.org/images/og/favicon-generator.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Favicon Generator - Free online favicon creation tool">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Favicon Generator - Code Utils">
    <meta name="twitter:description"
        content="Create favicons from text, emoji, or images. Generate multiple sizes instantly. Free tool with 100% private client-side processing.">
    <meta name="twitter:image" content="https://codeutils.org/images/og/favicon-generator.png">

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RPHPBJ4291"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-RPHPBJ4291');
    </script>

    <!-- Structured Data: WebApplication Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Favicon Generator - Code Utils",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Advanced favicon generator with unique gradient backgrounds (linear/radial), 10 custom fonts, and comprehensive size support (16x16 to 512x512). Create from text, 200+ emojis, or upload images. Features hexagon shapes, custom border radius, and platform preview mockups. Download as ZIP, ICO, or individual PNGs. 100% client-side processing - your images never leave your browser.",
      "url": "https://codeutils.org/favicon-generator",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0",
      "featureList": [
        "Gradient backgrounds (linear & radial) - UNIQUE!",
        "10 custom fonts (Arial, Georgia, Impact, etc.)",
        "Text, emoji (200+), and image upload",
        "9 comprehensive sizes: 16, 32, 64, 96, 128, 180, 192, 256, 512px",
        "5 shapes: square, rounded, circle, hexagon, custom radius",
        "Platform preview mockups (browser, iOS, Android)",
        "iOS, Android, PWA, Chrome, Windows support",
        "ZIP download with all sizes + README",
        "favicon.ico generation (multi-size)",
        "Drag & drop image upload",
        "Client-side processing - 100% private",
        "No data uploads, no limits",
        "Free forever"
      ]
    }
    </script>

    <!-- Structured Data: FAQ Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Is my logo/image safe when using this tool?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes, absolutely! All favicon generation happens entirely in your browser using JavaScript. Your images and data never leave your computer and are never uploaded to any server. We don't store, log, or transmit your images in any way. This makes our tool completely safe for proprietary logos, brand assets, or sensitive graphics. You can even use this tool offline after the initial page load."
          }
        },
        {
          "@type": "Question",
          "name": "What favicon sizes should I use for my website?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "For modern websites, you should include: 16x16 for browser tabs, 32x32 for taskbar shortcuts, 180x180 for iOS, 192x192 for Android, and 512x512 for PWAs. Our tool generates ALL 9 professional sizes: 16x16, 32x32, 64x64, 96x96 (Google TV), 128x128 (Chrome extensions), 180x180 (iOS), 192x192 (Android), 256x256 (Windows tiles), and 512x512 (PWA). Download everything in one ZIP file."
          }
        },
        {
          "@type": "Question",
          "name": "Do I need to create an account or sign up?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No! All our tools are completely free and don't require any registration, sign-up, or account creation. Just visit the page and start creating favicons immediately. There are no limits on usage, no premium tiers, and no hidden fees."
          }
        },
        {
          "@type": "Question",
          "name": "Can I create favicons from my company logo?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! You can use text, emoji, or upload your existing company logo to convert it into a favicon. Our tool supports multiple input methods to accommodate different use cases. Simply choose your preferred method and customize the colors and shapes to match your brand."
          }
        },
        {
          "@type": "Question",
          "name": "What file format are the generated favicons?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Our tool generates favicons in both PNG and ICO formats. PNG is supported by all modern browsers and provides better quality, while ICO format ensures compatibility with older browsers. You can download a complete ZIP package with all 9 sizes (16x16 through 512x512) plus favicon.ico and installation instructions, or download formats individually. The ZIP includes properly named files for each platform (apple-touch-icon.png, android-chrome-192x192.png, etc.)."
          }
        }
      ]
    }
    </script>

    <!-- JSZip for ZIP downloads -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <link rel="stylesheet" href="css/common.css">
    <style>
        .input-tabs {
            display: flex;
            gap: var(--spacing-xs);
            margin-bottom: var(--spacing-md);
            border-bottom: 2px solid var(--border);
        }

        .input-tab {
            padding: var(--spacing-sm) var(--spacing-md);
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-weight: 500;
            color: var(--text-secondary);
            margin-bottom: -2px;
        }

        .input-tab.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
        }

        .input-section {
            display: none;
        }

        .input-section.active {
            display: block;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: var(--radius);
            padding: var(--spacing-lg);
            text-align: center;
            background: var(--bg-secondary);
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: var(--spacing-md);
        }

        .upload-zone:hover,
        .upload-zone.drag-over {
            border-color: var(--primary);
            background: var(--bg-primary);
        }

        .upload-zone input[type="file"] {
            display: none;
        }

        .upload-icon {
            font-size: 3rem;
            margin-bottom: var(--spacing-sm);
        }

        .preview-container {
            display: flex;
            gap: var(--spacing-md);
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: var(--spacing-md);
        }

        .preview-box {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            text-align: center;
        }

        .preview-box canvas {
            border: 1px solid var(--border);
            background: white;
            display: block;
            margin: 0 auto;
        }

        .preview-box .label {
            margin-top: var(--spacing-xs);
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .option-group {
            background: var(--bg-secondary);
            padding: var(--spacing-md);
            border-radius: var(--radius);
        }

        .option-group label {
            display: block;
            margin-bottom: var(--spacing-xs);
            font-weight: bold;
        }

        .option-group input,
        .option-group select {
            width: 100%;
            padding: var(--spacing-xs);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            gap: 4px;
            margin-top: var(--spacing-xs);
            max-height: 200px;
            overflow-y: auto;
            padding: var(--spacing-xs);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }

        .emoji-btn {
            font-size: 1.5rem;
            padding: 8px;
            border: 1px solid var(--border);
            border-radius: 4px;
            background: var(--bg-secondary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .emoji-btn:hover {
            background: var(--primary);
            transform: scale(1.1);
        }

        .emoji-search {
            width: 100%;
            padding: var(--spacing-xs);
            margin-bottom: var(--spacing-xs);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        /* Gradient Stop Styles */
        .gradient-stop {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }

        .gradient-stop input[type="color"] {
            width: 60px;
            height: 36px;
            border: none;
            cursor: pointer;
        }

        .gradient-stop input[type="range"] {
            flex: 1;
        }

        .gradient-stop-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            min-width: 40px;
        }

        /* Template Styles */
        .template-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: var(--radius);
            padding: var(--spacing-sm);
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .template-card:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .template-preview {
            width: 80px;
            height: 80px;
            margin: 0 auto var(--spacing-xs);
            border-radius: var(--radius);
        }

        .template-name {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Platform Preview Styles */
        .platform-preview {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: var(--spacing-md);
            text-align: center;
        }

        .platform-label {
            font-weight: bold;
            margin-bottom: var(--spacing-sm);
            color: var(--text-primary);
        }

        /* Browser Tab Mock */
        .browser-tab {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 8px 8px 0 0;
            padding: 8px 12px;
            font-size: 0.875rem;
            color: var(--text-primary);
        }

        .tab-title {
            color: var(--text-primary);
        }

        .tab-close {
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 1.25rem;
            line-height: 1;
        }

        /* iOS Home Screen Mock */
        .ios-screen {
            display: inline-block;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
        }

        .ios-icon {
            margin-bottom: 8px;
        }

        .ios-icon canvas {
            display: block;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }

        .ios-app-name {
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        /* Android Home Screen Mock */
        .android-screen {
            display: inline-block;
            padding: var(--spacing-md);
            background: linear-gradient(135deg, #89f7fe 0%, #66a6ff 100%);
            border-radius: 8px;
        }

        .android-icon {
            margin-bottom: 8px;
        }

        .android-icon canvas {
            display: block;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            border-radius: 25%;
        }

        .android-app-name {
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
    </style>
</head>

<body>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="header-logo">
                <h1>Code Utils</h1>
            </a>
            <nav class="header-nav">
                <a href="index.html" class="btn btn-outline btn-sm">All Tools</a>
                <button class="theme-toggle" onclick="CodeUtils.Theme.toggle()">Toggle Dark Mode</button>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="card" style="margin-bottom: var(--spacing-md); padding: var(--spacing-md);">
            <h2 style="margin-bottom: var(--spacing-xs); color: var(--primary);">Favicon Generator</h2>
            <p style="margin: 0; color: var(--text-secondary);">Create favicons from text, emoji, or upload images. Generate all sizes instantly.</p>
        </div>

        <!-- Input Method Tabs -->
        <div class="input-tabs">
            <button class="input-tab active" onclick="switchInputTab('text')">Text & Emoji</button>
            <button class="input-tab" onclick="switchInputTab('upload')">Upload Image</button>
            <button class="input-tab" onclick="switchInputTab('templates')">Templates</button>
        </div>

        <!-- Templates Section -->
        <div id="templatesSection" class="input-section">
            <p style="margin-bottom: var(--spacing-md); color: var(--text-secondary);">Choose a pre-designed template to get started quickly. Click any template to apply it.</p>
            <div id="templateGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
                <!-- Templates populated by JavaScript -->
            </div>
        </div>

        <!-- Text/Emoji Input Section -->
        <div id="textSection" class="input-section active">
            <div class="options-grid">
                <div class="option-group">
                    <label>Text/Emoji</label>
                    <input type="text" id="textInput" value="CU" maxlength="4" oninput="generateFavicon()">
                    <input type="text" class="emoji-search" id="emojiSearch" placeholder="Search emoji..." oninput="filterEmojis()">
                    <div class="emoji-grid" id="emojiGrid"></div>
                </div>
                <div class="option-group">
                    <label>Font Family</label>
                    <select id="fontFamily" onchange="generateFavicon()">
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Helvetica, sans-serif">Helvetica</option>
                        <option value="'Times New Roman', serif">Times New Roman</option>
                        <option value="Georgia, serif">Georgia</option>
                        <option value="'Courier New', monospace">Courier New</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="'Trebuchet MS', sans-serif">Trebuchet MS</option>
                        <option value="Impact, sans-serif">Impact</option>
                        <option value="'Comic Sans MS', cursive">Comic Sans MS</option>
                        <option value="'Brush Script MT', cursive">Brush Script</option>
                    </select>
                </div>
                <div class="option-group">
                    <label>Background Type</label>
                    <select id="bgType" onchange="toggleBackgroundType()">
                        <option value="solid">Solid Color</option>
                        <option value="linear">Linear Gradient</option>
                        <option value="radial">Radial Gradient</option>
                        <option value="pattern">Pattern</option>
                    </select>
                </div>
                <div class="option-group" id="solidColorGroup">
                    <label>Background Color</label>
                    <input type="color" id="bgColor" value="#3b82f6" onchange="generateFavicon()">
                </div>
                <div class="option-group" id="patternGroup" style="display: none;">
                    <label>Pattern Type</label>
                    <select id="patternType" onchange="generateFavicon()">
                        <option value="stripes">Stripes</option>
                        <option value="dots">Dots</option>
                        <option value="checkerboard">Checkerboard</option>
                        <option value="diagonal">Diagonal Lines</option>
                        <option value="grid">Grid</option>
                    </select>
                    <label style="margin-top: 8px;">Pattern Color 1</label>
                    <input type="color" id="patternColor1" value="#3b82f6" onchange="generateFavicon()" style="width: 100%; margin-bottom: 8px;">
                    <label>Pattern Color 2</label>
                    <input type="color" id="patternColor2" value="#8b5cf6" onchange="generateFavicon()" style="width: 100%;">
                </div>
                <div class="option-group" id="gradientGroup" style="display: none;">
                    <label>Gradient Color Stops</label>
                    <div id="gradientStops">
                        <!-- Dynamically populated color stops -->
                    </div>
                    <div style="display: flex; gap: 8px; margin-top: 8px;">
                        <button type="button" class="btn btn-sm" onclick="addGradientStop()" style="flex: 1;">+ Add Color</button>
                        <button type="button" class="btn btn-sm btn-secondary" onclick="removeGradientStop()" style="flex: 1;">- Remove</button>
                    </div>
                    <label style="font-size: 0.875rem; margin-top: 12px;">Angle (Linear) / Position (Radial)</label>
                    <input type="range" id="gradientAngle" min="0" max="360" value="45" oninput="generateFavicon()" style="width: 100%;">
                    <span id="angleValue" style="font-size: 0.75rem; color: var(--text-secondary);">45¬∞</span>
                </div>
                <div class="option-group">
                    <label>Text Color</label>
                    <input type="color" id="textColor" value="#ffffff" onchange="generateFavicon()">
                </div>
                <div class="option-group">
                    <label>Shape</label>
                    <select id="shape" onchange="generateFavicon()">
                        <option value="square">Square</option>
                        <option value="rounded">Rounded</option>
                        <option value="circle">Circle</option>
                        <option value="hexagon">Hexagon</option>
                        <option value="custom">Custom Radius</option>
                    </select>
                </div>
                <div class="option-group" id="customRadiusGroup" style="display: none;">
                    <label>Border Radius: <span id="radiusValue">20%</span></label>
                    <input type="range" id="borderRadius" min="0" max="50" value="20" oninput="updateRadius()" style="width: 100%;">
                </div>
                <div class="option-group">
                    <label>
                        <input type="checkbox" id="enableShadow" onchange="toggleShadow()"> Text Shadow
                    </label>
                    <div id="shadowControls" style="display: none; margin-top: 8px;">
                        <label style="font-size: 0.875rem;">Shadow Color</label>
                        <input type="color" id="shadowColor" value="#000000" onchange="generateFavicon()" style="width: 100%; margin-bottom: 8px;">
                        <label style="font-size: 0.875rem;">Blur: <span id="shadowBlurValue">4px</span></label>
                        <input type="range" id="shadowBlur" min="0" max="20" value="4" oninput="updateShadowBlur()" style="width: 100%; margin-bottom: 8px;">
                        <label style="font-size: 0.875rem;">Offset X: <span id="shadowXValue">2px</span></label>
                        <input type="range" id="shadowX" min="-10" max="10" value="2" oninput="updateShadowX()" style="width: 100%; margin-bottom: 8px;">
                        <label style="font-size: 0.875rem;">Offset Y: <span id="shadowYValue">2px</span></label>
                        <input type="range" id="shadowY" min="-10" max="10" value="2" oninput="updateShadowY()" style="width: 100%;">
                    </div>
                </div>
            </div>
        </div>

        <!-- Upload Image Section -->
        <div id="uploadSection" class="input-section">
            <div class="upload-zone" id="uploadZone">
                <input type="file" id="imageUpload" accept="image/*" onchange="handleImageUpload(event)">
                <div class="upload-icon">üìÅ</div>
                <p>Click to upload or drag & drop an image</p>
                <p style="font-size: 0.875rem; color: var(--text-secondary);">PNG, JPG, GIF, SVG supported</p>
            </div>
            <div class="options-grid">
                <div class="option-group">
                    <label>Background Color (if transparent)</label>
                    <input type="color" id="uploadBgColor" value="#3b82f6" onchange="generateFromImage()">
                </div>
                <div class="option-group">
                    <label>Shape</label>
                    <select id="uploadShape" onchange="generateFromImage()">
                        <option value="square">Square</option>
                        <option value="rounded">Rounded</option>
                        <option value="circle">Circle</option>
                    </select>
                </div>
            </div>
        </div>

        <h3 style="margin-top: var(--spacing-lg); margin-bottom: var(--spacing-md);">Preview - All Sizes</h3>
        <div class="preview-container">
            <div class="preview-box">
                <canvas id="preview512" width="512" height="512" style="max-width: 128px; max-height: 128px;"></canvas>
                <div class="label">512x512 (PWA)</div>
            </div>
            <div class="preview-box">
                <canvas id="preview256" width="256" height="256" style="max-width: 128px; max-height: 128px;"></canvas>
                <div class="label">256x256 (Windows)</div>
            </div>
            <div class="preview-box">
                <canvas id="preview192" width="192" height="192" style="max-width: 96px; max-height: 96px;"></canvas>
                <div class="label">192x192 (Android)</div>
            </div>
            <div class="preview-box">
                <canvas id="preview180" width="180" height="180" style="max-width: 90px; max-height: 90px;"></canvas>
                <div class="label">180x180 (iOS)</div>
            </div>
            <div class="preview-box">
                <canvas id="preview128" width="128" height="128" style="max-width: 64px; max-height: 64px;"></canvas>
                <div class="label">128x128 (Chrome)</div>
            </div>
            <div class="preview-box">
                <canvas id="preview96" width="96" height="96" style="max-width: 64px; max-height: 64px;"></canvas>
                <div class="label">96x96 (Google TV)</div>
            </div>
            <div class="preview-box">
                <canvas id="preview64" width="64" height="64"></canvas>
                <div class="label">64x64</div>
            </div>
            <div class="preview-box">
                <canvas id="preview32" width="32" height="32"></canvas>
                <div class="label">32x32</div>
            </div>
            <div class="preview-box">
                <canvas id="preview16" width="16" height="16"></canvas>
                <div class="label">16x16</div>
            </div>
        </div>

        <!-- Platform Preview Mockups -->
        <h3 style="margin-top: var(--spacing-lg); margin-bottom: var(--spacing-md);">Platform Previews</h3>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: var(--spacing-md); margin-bottom: var(--spacing-md);">
            <!-- Browser Tab Preview -->
            <div class="platform-preview">
                <div class="platform-label">Browser Tab</div>
                <div class="browser-tab">
                    <canvas id="previewBrowserTab" width="16" height="16" style="width: 16px; height: 16px;"></canvas>
                    <span class="tab-title">Your Website</span>
                    <span class="tab-close">√ó</span>
                </div>
            </div>

            <!-- iOS Home Screen Preview -->
            <div class="platform-preview">
                <div class="platform-label">iOS Home Screen</div>
                <div class="ios-screen">
                    <div class="ios-icon">
                        <canvas id="previewIOS" width="180" height="180" style="width: 60px; height: 60px; border-radius: 13px;"></canvas>
                    </div>
                    <div class="ios-app-name">Your App</div>
                </div>
            </div>

            <!-- Android Home Screen Preview -->
            <div class="platform-preview">
                <div class="platform-label">Android Home Screen</div>
                <div class="android-screen">
                    <div class="android-icon">
                        <canvas id="previewAndroid" width="192" height="192" style="width: 60px; height: 60px;"></canvas>
                    </div>
                    <div class="android-app-name">Your App</div>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="downloadZip()">üì¶ Download All (ZIP)</button>
            <button class="btn" onclick="downloadIco()">Download favicon.ico</button>
            <button class="btn" onclick="downloadSvg()">Download SVG</button>
            <button class="btn btn-secondary" onclick="downloadIndividual()">Download Individual PNGs</button>
        </div>

        <div id="message" class="message"></div>

        <div class="editor-section" style="margin-top: var(--spacing-md);">
            <div class="editor-header">HTML Code (Add to &lt;head&gt;)</div>
            <textarea id="htmlCode" class="editor" readonly style="height: 220px;"><link rel="icon" type="image/x-icon" href="/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="64x64" href="/favicon-64x64.png">
<link rel="icon" type="image/png" sizes="96x96" href="/google-tv-96x96.png">
<link rel="icon" type="image/png" sizes="128x128" href="/chrome-extension-128x128.png">
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="192x192" href="/android-chrome-192x192.png">
<link rel="icon" type="image/png" sizes="256x256" href="/windows-tile-256x256.png">
<link rel="icon" type="image/png" sizes="512x512" href="/android-chrome-512x512.png"></textarea>
        </div>

        <div class="related-tools">
            <h3>Related Tools</h3>
            <ul class="related-tools-list">
                <li><a href="meta-generator.html">Meta Tag Generator</a></li>
                <li><a href="color-picker.html">Color Picker</a></li>
                <li><a href="qr-generator.html">QR Code Generator</a></li>
            </ul>
        </div>

        <div class="info-section">
            <h2>About Favicons</h2>
            <p>Favicons are small icons displayed in browser tabs, bookmarks, and address bars.</p>

            <h3>Recommended Sizes</h3>
            <ul>
                <li><strong>16x16:</strong> Browser tabs (traditional)</li>
                <li><strong>32x32:</strong> Taskbar shortcuts, high-DPI tabs</li>
                <li><strong>64x64:</strong> High-resolution displays</li>
                <li><strong>180x180:</strong> Apple Touch Icon</li>
                <li><strong>512x512:</strong> PWA icons</li>
            </ul>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 Code Utils. All rights reserved.</p>
        <p>Free developer utilities - 100% client-side processing</p>
    </footer>

    <script src="js/common.js"></script>
    <script>
        CodeUtils.RecentTools.add({
            id: 'favicon-generator',
            name: 'Favicon Generator',
            url: 'favicon-generator.html'
        });

        CodeUtils.Message.init('message');

        // All favicon sizes to generate
        const SIZES = [16, 32, 64, 96, 128, 180, 192, 256, 512];

        // Comprehensive emoji library
        const EMOJI_LIBRARY = {
            'Popular': ['üòÄ', 'üòÉ', 'üòÑ', 'üòÅ', 'üòÖ', 'üòÇ', 'ü§£', 'üòä', 'üòá', 'üôÇ', 'üôÉ', 'üòâ', 'üòå', 'üòç', 'ü•∞', 'üòò', 'üòó', 'üòô', 'üòö', 'üòã', 'üòõ', 'üòù', 'üòú', 'ü§™', 'ü§®', 'üßê', 'ü§ì', 'üòé', 'ü§©', 'ü•≥'],
            'Symbols': ['‚ù§Ô∏è', 'üíô', 'üíö', 'üíõ', 'üß°', 'üíú', 'üñ§', 'ü§ç', 'ü§é', 'üíî', '‚ù£Ô∏è', 'üíï', 'üíû', 'üíì', 'üíó', 'üíñ', 'üíò', 'üíù', '‚≠ê', 'üåü', '‚ú®', '‚ö°', 'üî•', 'üí•', 'üí´', 'üí¶', 'üí®', 'üåà', '‚òÄÔ∏è', 'üåô'],
            'Tech': ['üíª', '‚å®Ô∏è', 'üñ•Ô∏è', 'üñ®Ô∏è', 'üñ±Ô∏è', 'üíæ', 'üíø', 'üìÄ', 'üì±', 'üì≤', '‚òéÔ∏è', 'üìû', 'üìü', 'üì†', 'üì°', 'üîã', 'üîå', 'üí°', 'üî¶', 'üïØÔ∏è', 'ü™î', 'üßØ', 'üõ¢Ô∏è', 'üí∏', 'üíµ', 'üí¥', 'üí∂', 'üí∑', 'üí∞', 'üí≥'],
            'Objects': ['üéØ', 'üé™', 'üé®', 'üé¨', 'üé§', 'üéß', 'üéº', 'üéπ', 'ü•Å', 'üé∑', 'üé∫', 'üé∏', 'ü™ï', 'üéª', 'üé≤', '‚ôüÔ∏è', 'üéØ', 'üé≥', 'üéÆ', 'üé∞', 'üß©', 'üß∏', 'ü™Ä', 'ü™Å', 'üé™', 'üé≠', 'üñºÔ∏è', 'üé®', 'üßµ', 'ü™°'],
            'Nature': ['üå±', 'üåø', '‚òòÔ∏è', 'üçÄ', 'üéã', 'üéç', 'üåæ', 'üåµ', 'üå¥', 'üå≥', 'üå≤', 'üèîÔ∏è', '‚õ∞Ô∏è', 'üåã', 'üóª', 'üèïÔ∏è', 'üèñÔ∏è', 'üèúÔ∏è', 'üèùÔ∏è', 'üèûÔ∏è', 'üåÖ', 'üåÑ', 'üå†', 'üéá', 'üéÜ', 'üåá', 'üåÜ', 'üèôÔ∏è', 'üåÉ', 'üåå'],
            'Food': ['üçé', 'üçè', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü´ê', 'üçà', 'üçí', 'üçë', 'ü•≠', 'üçç', 'ü••', 'ü•ù', 'üçÖ', 'üçÜ', 'ü•ë', 'ü•¶', 'ü•¨', 'ü•í', 'üå∂Ô∏è', 'ü´ë', 'üåΩ', 'ü•ï', 'ü´í', 'üßÑ', 'üßÖ', 'ü•î'],
            'Activities': ['‚öΩ', 'üèÄ', 'üèà', '‚öæ', 'ü•é', 'üéæ', 'üèê', 'üèâ', 'ü•è', 'üé±', 'ü™Ä', 'üèì', 'üè∏', 'üèí', 'üèë', 'ü•ç', 'üèè', 'ü™É', 'ü•Ö', '‚õ≥', 'ü™Å', 'üèπ', 'üé£', 'ü§ø', 'ü•ä', 'ü•ã', 'üéΩ', 'üõπ', 'üõº', 'üõ∑'],
            'Vehicles': ['üöó', 'üöï', 'üöô', 'üöå', 'üöé', 'üèéÔ∏è', 'üöì', 'üöë', 'üöí', 'üöê', 'üõª', 'üöö', 'üöõ', 'üöú', 'üõ¥', 'üö≤', 'üõµ', 'üèçÔ∏è', 'üõ∫', 'üö®', 'üöî', 'üöç', 'üöò', 'üöñ', 'üö°', 'üö†', 'üöü', 'üöÉ', 'üöã', 'üöû'],
            'Flags': ['üèÅ', 'üö©', 'üéå', 'üè¥', 'üè≥Ô∏è', 'üè≥Ô∏è‚Äçüåà', 'üè≥Ô∏è‚Äç‚ößÔ∏è', 'üè¥‚Äç‚ò†Ô∏è', 'üá∫üá∏', 'üá¨üáß', 'üá®üá¶', 'üá¶üá∫', 'üá©üá™', 'üá´üá∑', 'üá™üá∏', 'üáÆüáπ', 'üáØüáµ', 'üá∞üá∑', 'üá®üá≥', 'üáÆüá≥', 'üáßüá∑', 'üá≤üáΩ', 'üá∑üá∫', 'üáøüá¶', 'üá∏üá™', 'üá≥üá¥', 'üá©üá∞', 'üá´üáÆ', 'üá≥üá±', 'üáßüá™']
        };

        // Emoji keyword mapping for search
        const EMOJI_KEYWORDS = {
            'üòÄ': ['smile', 'happy', 'joy', 'grin', 'face'],
            'üòÉ': ['smile', 'happy', 'joy', 'big', 'grin'],
            'üòÑ': ['smile', 'happy', 'laugh', 'joy'],
            'üòÅ': ['grin', 'smile', 'happy', 'teeth'],
            'üòÖ': ['sweat', 'relief', 'phew', 'laugh'],
            'üòÇ': ['laugh', 'tears', 'joy', 'lol', 'funny'],
            'ü§£': ['rofl', 'laugh', 'rolling', 'floor'],
            'üòä': ['blush', 'smile', 'happy', 'shy'],
            'üòá': ['angel', 'innocent', 'halo', 'saint'],
            'üòç': ['love', 'heart', 'eyes', 'adore'],
            'ü•∞': ['love', 'hearts', 'smile', 'affection'],
            'üòò': ['kiss', 'love', 'heart', 'blow'],
            'üòé': ['cool', 'sunglasses', 'awesome', 'rad'],
            'ü§©': ['star', 'wow', 'excited', 'amazed'],
            'ü•≥': ['party', 'celebrate', 'birthday', 'hat'],
            '‚ù§Ô∏è': ['heart', 'love', 'red', 'romance'],
            'üíô': ['heart', 'blue', 'love', 'loyal'],
            'üíö': ['heart', 'green', 'love', 'nature'],
            'üíõ': ['heart', 'yellow', 'love', 'gold'],
            'üß°': ['heart', 'orange', 'love', 'warm'],
            'üíú': ['heart', 'purple', 'love', 'passion'],
            'üñ§': ['heart', 'black', 'love', 'dark'],
            'ü§ç': ['heart', 'white', 'love', 'pure'],
            '‚≠ê': ['star', 'favorite', 'best', 'gold'],
            'üåü': ['star', 'sparkle', 'shine', 'glow'],
            '‚ú®': ['sparkle', 'shine', 'magic', 'glitter'],
            '‚ö°': ['lightning', 'bolt', 'electric', 'power', 'fast'],
            'üî•': ['fire', 'hot', 'flame', 'burn', 'lit'],
            'üí•': ['boom', 'explosion', 'bang', 'crash'],
            'üåà': ['rainbow', 'color', 'pride', 'arc'],
            '‚òÄÔ∏è': ['sun', 'sunny', 'bright', 'day', 'weather'],
            'üåô': ['moon', 'night', 'crescent', 'dark'],
            'üíª': ['computer', 'laptop', 'tech', 'work', 'code'],
            '‚å®Ô∏è': ['keyboard', 'type', 'keys', 'input'],
            'üñ•Ô∏è': ['desktop', 'computer', 'monitor', 'screen'],
            'üñ®Ô∏è': ['printer', 'print', 'paper', 'office'],
            'üñ±Ô∏è': ['mouse', 'click', 'cursor', 'pointer'],
            'üíæ': ['floppy', 'disk', 'save', 'storage'],
            'üíø': ['cd', 'disc', 'music', 'data'],
            'üìÄ': ['dvd', 'disc', 'video', 'movie'],
            'üì±': ['phone', 'mobile', 'cell', 'smartphone'],
            'üì≤': ['phone', 'call', 'mobile', 'arrow'],
            '‚òéÔ∏è': ['phone', 'telephone', 'call', 'old'],
            'üìû': ['phone', 'receiver', 'call'],
            'üîã': ['battery', 'power', 'charge', 'energy'],
            'üîå': ['plug', 'electric', 'power', 'socket'],
            'üí°': ['bulb', 'light', 'idea', 'bright', 'innovation'],
            'üî¶': ['flashlight', 'torch', 'light'],
            'üöÄ': ['rocket', 'space', 'launch', 'fast', 'startup'],
            'üéØ': ['target', 'dart', 'goal', 'bullseye', 'aim'],
            'üé®': ['art', 'paint', 'palette', 'creative', 'design'],
            'üé¨': ['movie', 'film', 'cinema', 'action', 'video'],
            'üé§': ['microphone', 'sing', 'music', 'voice'],
            'üéß': ['headphones', 'music', 'listen', 'audio'],
            'üéÆ': ['game', 'controller', 'gaming', 'play', 'video'],
            'üé≤': ['dice', 'game', 'random', 'chance'],
            'üß©': ['puzzle', 'piece', 'game', 'solve'],
            'üå±': ['plant', 'grow', 'seedling', 'green', 'nature'],
            'üåø': ['herb', 'leaf', 'green', 'nature'],
            'üçÄ': ['clover', 'luck', 'four', 'irish', 'green'],
            'üåµ': ['cactus', 'desert', 'plant', 'prickly'],
            'üå¥': ['palm', 'tree', 'tropical', 'beach'],
            'üå≥': ['tree', 'nature', 'green', 'forest'],
            'üèîÔ∏è': ['mountain', 'peak', 'snow', 'high'],
            'üåã': ['volcano', 'lava', 'erupt', 'mountain'],
            'üèñÔ∏è': ['beach', 'sand', 'ocean', 'vacation'],
            'üåÖ': ['sunrise', 'sunset', 'dawn', 'morning'],
            'üåÜ': ['city', 'sunset', 'buildings', 'dusk'],
            'üèôÔ∏è': ['city', 'buildings', 'urban', 'skyline'],
            'üåÉ': ['city', 'night', 'stars', 'urban'],
            'üçé': ['apple', 'fruit', 'red', 'food', 'healthy'],
            'üçè': ['apple', 'green', 'fruit', 'food'],
            'üçä': ['orange', 'fruit', 'citrus', 'food'],
            'üçã': ['lemon', 'yellow', 'citrus', 'sour'],
            'üçå': ['banana', 'yellow', 'fruit', 'food'],
            'üçâ': ['watermelon', 'fruit', 'summer', 'red'],
            'üçá': ['grapes', 'fruit', 'purple', 'wine'],
            'üçì': ['strawberry', 'fruit', 'red', 'berry'],
            'üçë': ['peach', 'fruit', 'orange', 'fuzzy'],
            'üçç': ['pineapple', 'fruit', 'tropical', 'yellow'],
            'ü••': ['coconut', 'fruit', 'tropical', 'brown'],
            'ü•ù': ['kiwi', 'fruit', 'green', 'fuzzy'],
            'üçÖ': ['tomato', 'red', 'vegetable', 'food'],
            'ü•ë': ['avocado', 'green', 'fruit', 'healthy'],
            'ü•¶': ['broccoli', 'green', 'vegetable', 'healthy'],
            'üåΩ': ['corn', 'yellow', 'vegetable', 'food'],
            'ü•ï': ['carrot', 'orange', 'vegetable', 'food'],
            '‚öΩ': ['soccer', 'football', 'ball', 'sport'],
            'üèÄ': ['basketball', 'ball', 'sport', 'hoop'],
            'üèà': ['football', 'american', 'ball', 'sport'],
            '‚öæ': ['baseball', 'ball', 'sport', 'game'],
            'üéæ': ['tennis', 'ball', 'sport', 'racket'],
            'üèê': ['volleyball', 'ball', 'sport', 'beach'],
            'üèì': ['ping', 'pong', 'table', 'tennis'],
            'üè∏': ['badminton', 'shuttlecock', 'racket'],
            'ü•ä': ['boxing', 'glove', 'fight', 'sport'],
            'ü•ã': ['martial', 'arts', 'karate', 'judo'],
            'üõπ': ['skateboard', 'skate', 'sport', 'board'],
            'üöó': ['car', 'auto', 'vehicle', 'drive'],
            'üöï': ['taxi', 'cab', 'car', 'transport'],
            'üöô': ['suv', 'car', 'vehicle', 'auto'],
            'üöå': ['bus', 'transport', 'public', 'vehicle'],
            'üèéÔ∏è': ['race', 'car', 'fast', 'formula'],
            'üöì': ['police', 'car', 'cop', 'law'],
            'üöë': ['ambulance', 'emergency', 'medical'],
            'üöí': ['fire', 'truck', 'emergency', 'engine'],
            'üö≤': ['bicycle', 'bike', 'cycle', 'ride'],
            'üõµ': ['scooter', 'motor', 'moped', 'bike'],
            'üèçÔ∏è': ['motorcycle', 'bike', 'motor', 'ride'],
            '‚úàÔ∏è': ['airplane', 'plane', 'flight', 'travel'],
            'üöÅ': ['helicopter', 'chopper', 'flight'],
            'üöÇ': ['train', 'locomotive', 'railway'],
            'üö¢': ['ship', 'boat', 'cruise', 'ocean'],
            '‚õµ': ['sailboat', 'boat', 'sail', 'yacht'],
            'üö§': ['speedboat', 'boat', 'motor', 'fast'],
            'üèÅ': ['checkered', 'flag', 'race', 'finish'],
            'üö©': ['red', 'flag', 'warning', 'mark'],
            'üéå': ['flag', 'crossed', 'japan'],
            'üè≥Ô∏è‚Äçüåà': ['pride', 'rainbow', 'lgbt', 'flag']
        };

        let currentInputMode = 'text';
        let uploadedImage = null;
        let allEmojis = [];
        let emojiKeywordMap = new Map();
        let gradientStops = [
            { color: '#3b82f6', position: 0 },
            { color: '#8b5cf6', position: 100 }
        ];

        // Favicon templates
        const TEMPLATES = [
            { name: 'Tech Startup', text: 'üöÄ', bgType: 'linear', colors: ['#667eea', '#764ba2'], font: 'Arial, sans-serif', shape: 'rounded' },
            { name: 'E-commerce', text: 'üõí', bgType: 'linear', colors: ['#f093fb', '#f5576c'], font: 'Arial, sans-serif', shape: 'rounded' },
            { name: 'Blog', text: '‚úèÔ∏è', bgType: 'solid', colors: ['#ff6b6b'], font: 'Georgia, serif', shape: 'circle' },
            { name: 'Portfolio', text: 'üíº', bgType: 'linear', colors: ['#4facfe', '#00f2fe'], font: 'Helvetica, sans-serif', shape: 'square' },
            { name: 'Gaming', text: 'üéÆ', bgType: 'linear', colors: ['#fa709a', '#fee140'], font: 'Impact, sans-serif', shape: 'hexagon' },
            { name: 'Music', text: 'üéµ', bgType: 'radial', colors: ['#a8edea', '#fed6e3'], font: 'Arial, sans-serif', shape: 'circle' },
            { name: 'Food & Drink', text: 'üçï', bgType: 'solid', colors: ['#ff8a00'], font: 'Arial, sans-serif', shape: 'rounded' },
            { name: 'Travel', text: '‚úàÔ∏è', bgType: 'linear', colors: ['#30cfd0', '#330867'], font: 'Verdana, sans-serif', shape: 'rounded' },
            { name: 'Finance', text: 'üí∞', bgType: 'linear', colors: ['#1e3c72', '#2a5298'], font: 'Georgia, serif', shape: 'square' },
            { name: 'Health & Fitness', text: 'üí™', bgType: 'linear', colors: ['#56ab2f', '#a8e063'], font: 'Arial, sans-serif', shape: 'circle' },
            { name: 'Education', text: 'üìö', bgType: 'solid', colors: ['#3b82f6'], font: 'Arial, sans-serif', shape: 'rounded' },
            { name: 'Creative', text: 'üé®', bgType: 'linear', colors: ['#ff0080', '#ff8c00', '#40e0d0'], font: 'Brush Script MT, cursive', shape: 'custom' },
            { name: 'Corporate', text: 'C', bgType: 'solid', colors: ['#2c3e50'], font: 'Arial, sans-serif', shape: 'square' },
            { name: 'Social', text: 'üí¨', bgType: 'radial', colors: ['#ee9ca7', '#ffdde1'], font: 'Verdana, sans-serif', shape: 'circle' },
            { name: 'Minimalist', text: 'M', bgType: 'solid', colors: ['#ffffff'], font: 'Helvetica, sans-serif', shape: 'square' }
        ];

        // Initialize
        function init() {
            // Flatten emoji library
            Object.values(EMOJI_LIBRARY).forEach(emojis => {
                allEmojis = allEmojis.concat(emojis);
            });

            // Build keyword map for search
            allEmojis.forEach(emoji => {
                const keywords = EMOJI_KEYWORDS[emoji] || [];
                emojiKeywordMap.set(emoji, keywords);
            });

            // Populate emoji grid
            populateEmojiGrid(allEmojis);

            // Initialize gradient stops UI
            renderGradientStops();

            // Initialize templates
            renderTemplates();

            // Setup drag & drop
            const uploadZone = document.getElementById('uploadZone');
            uploadZone.addEventListener('click', () => document.getElementById('imageUpload').click());
            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('drag-over');
            });
            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('drag-over');
            });
            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('drag-over');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadImageFile(file);
                }
            });

            // Initial generation
            generateFavicon();
        }

        // Populate emoji grid
        function populateEmojiGrid(emojis) {
            const grid = document.getElementById('emojiGrid');
            grid.innerHTML = '';
            emojis.slice(0, 100).forEach(emoji => {
                const btn = document.createElement('span');
                btn.className = 'emoji-btn';
                btn.textContent = emoji;
                btn.onclick = () => setEmoji(emoji);
                grid.appendChild(btn);
            });
        }

        // Filter emojis based on search
        function filterEmojis() {
            const search = document.getElementById('emojiSearch').value.toLowerCase().trim();
            if (!search) {
                populateEmojiGrid(allEmojis);
                return;
            }

            // Filter by keywords
            const filtered = allEmojis.filter(emoji => {
                const keywords = emojiKeywordMap.get(emoji) || [];
                // Check if emoji itself matches (for copy-paste search)
                if (emoji.includes(search)) return true;
                // Check if any keyword contains the search term
                return keywords.some(keyword => keyword.includes(search));
            });

            populateEmojiGrid(filtered);

            // Show message if no results
            if (filtered.length === 0) {
                const grid = document.getElementById('emojiGrid');
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; padding: var(--spacing-md); color: var(--text-secondary);">No emojis found for "' + search + '"</div>';
            }
        }

        // Render gradient stops UI
        function renderGradientStops() {
            const container = document.getElementById('gradientStops');
            container.innerHTML = '';

            gradientStops.forEach((stop, index) => {
                const stopDiv = document.createElement('div');
                stopDiv.className = 'gradient-stop';
                stopDiv.innerHTML = `
                    <input type="color" value="${stop.color}" onchange="updateGradientStopColor(${index}, this.value)">
                    <input type="range" min="0" max="100" value="${stop.position}" oninput="updateGradientStopPosition(${index}, this.value)">
                    <span class="gradient-stop-label">${stop.position}%</span>
                `;
                container.appendChild(stopDiv);
            });
        }

        // Add gradient stop
        function addGradientStop() {
            if (gradientStops.length >= 4) {
                CodeUtils.Message.warning('Maximum 4 color stops allowed');
                return;
            }

            // Add new stop in the middle
            const newPosition = gradientStops.length === 2 ? 50 :
                                gradientStops.length === 3 ? 67 : 75;
            const newColor = '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');

            gradientStops.push({ color: newColor, position: newPosition });
            gradientStops.sort((a, b) => a.position - b.position);

            renderGradientStops();
            generateFavicon();
        }

        // Remove gradient stop
        function removeGradientStop() {
            if (gradientStops.length <= 2) {
                CodeUtils.Message.warning('Minimum 2 color stops required');
                return;
            }

            gradientStops.pop();
            renderGradientStops();
            generateFavicon();
        }

        // Update gradient stop color
        function updateGradientStopColor(index, color) {
            gradientStops[index].color = color;
            generateFavicon();
        }

        // Update gradient stop position
        function updateGradientStopPosition(index, position) {
            gradientStops[index].position = parseInt(position);
            // Update the label
            const labels = document.querySelectorAll('.gradient-stop-label');
            if (labels[index]) {
                labels[index].textContent = position + '%';
            }
            generateFavicon();
        }

        // Render templates
        function renderTemplates() {
            const grid = document.getElementById('templateGrid');
            grid.innerHTML = '';

            TEMPLATES.forEach((template, index) => {
                const card = document.createElement('div');
                card.className = 'template-card';
                card.onclick = () => applyTemplate(index);

                // Create mini preview
                const preview = document.createElement('div');
                preview.className = 'template-preview';
                preview.style.background = template.bgType === 'solid' ?
                    template.colors[0] :
                    `linear-gradient(45deg, ${template.colors.join(', ')})`;
                preview.style.display = 'flex';
                preview.style.alignItems = 'center';
                preview.style.justifyContent = 'center';
                preview.style.fontSize = '2rem';
                preview.textContent = template.text;

                const name = document.createElement('div');
                name.className = 'template-name';
                name.textContent = template.name;

                card.appendChild(preview);
                card.appendChild(name);
                grid.appendChild(card);
            });
        }

        // Apply template
        function applyTemplate(index) {
            const template = TEMPLATES[index];

            // Switch to text mode
            currentInputMode = 'text';
            document.querySelectorAll('.input-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.input-tab')[0].classList.add('active');
            document.getElementById('textSection').classList.add('active');
            document.getElementById('uploadSection').classList.remove('active');
            document.getElementById('templatesSection').classList.remove('active');

            // Apply template settings
            document.getElementById('textInput').value = template.text;
            document.getElementById('fontFamily').value = template.font;
            document.getElementById('shape').value = template.shape;
            document.getElementById('bgType').value = template.bgType;

            if (template.bgType === 'solid') {
                document.getElementById('bgColor').value = template.colors[0];
            } else {
                // Update gradient stops
                gradientStops = template.colors.map((color, i) => ({
                    color: color,
                    position: i * (100 / (template.colors.length - 1))
                }));
                renderGradientStops();
            }

            // Update text color for contrast
            const bgColor = template.colors[0];
            const rgb = parseInt(bgColor.slice(1), 16);
            const r = (rgb >> 16) & 0xff;
            const g = (rgb >> 8) & 0xff;
            const b = (rgb >> 0) & 0xff;
            const brightness = (r * 299 + g * 587 + b * 114) / 1000;
            document.getElementById('textColor').value = brightness > 128 ? '#000000' : '#ffffff';

            toggleBackgroundType();
            toggleShapeControls();
            generateFavicon();

            CodeUtils.Message.success(`Applied template: ${template.name}`);
        }

        // Switch input tabs
        function switchInputTab(mode) {
            currentInputMode = mode;

            // Update tab buttons
            document.querySelectorAll('.input-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update sections
            document.getElementById('textSection').classList.toggle('active', mode === 'text');
            document.getElementById('uploadSection').classList.toggle('active', mode === 'upload');
            document.getElementById('templatesSection').classList.toggle('active', mode === 'templates');

            // Generate based on current mode
            if (mode === 'text') {
                generateFavicon();
            } else if (mode === 'upload' && uploadedImage) {
                generateFromImage();
            }
        }

        // Set emoji
        function setEmoji(emoji) {
            document.getElementById('textInput').value = emoji;
            generateFavicon();
        }

        // Handle image upload
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (file) {
                loadImageFile(file);
            }
        }

        // Load image file
        function loadImageFile(file) {
            // Check file size
            if (file.size > 10 * 1024 * 1024) {
                CodeUtils.Message.error('Image too large! Please use an image under 10MB.');
                return;
            }
            if (file.size > 2 * 1024 * 1024) {
                CodeUtils.Message.warning('Large image detected. Processing may be slow.');
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    uploadedImage = img;
                    generateFromImage();
                    CodeUtils.Message.success('Image loaded successfully!');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Toggle background type controls
        function toggleBackgroundType() {
            const bgType = document.getElementById('bgType').value;
            document.getElementById('solidColorGroup').style.display = bgType === 'solid' ? 'block' : 'none';
            document.getElementById('patternGroup').style.display = bgType === 'pattern' ? 'block' : 'none';
            document.getElementById('gradientGroup').style.display = (bgType === 'linear' || bgType === 'radial') ? 'block' : 'none';
            generateFavicon();
        }

        // Create pattern
        function createPattern(ctx, size, patternType, color1, color2) {
            const patternCanvas = document.createElement('canvas');
            const patternSize = Math.max(16, size / 8);
            patternCanvas.width = patternSize;
            patternCanvas.height = patternSize;
            const pCtx = patternCanvas.getContext('2d');

            switch(patternType) {
                case 'stripes':
                    // Vertical stripes
                    pCtx.fillStyle = color1;
                    pCtx.fillRect(0, 0, patternSize, patternSize);
                    pCtx.fillStyle = color2;
                    pCtx.fillRect(patternSize / 2, 0, patternSize / 2, patternSize);
                    break;

                case 'dots':
                    // Polka dots
                    pCtx.fillStyle = color1;
                    pCtx.fillRect(0, 0, patternSize, patternSize);
                    pCtx.fillStyle = color2;
                    pCtx.beginPath();
                    pCtx.arc(patternSize / 4, patternSize / 4, patternSize / 6, 0, Math.PI * 2);
                    pCtx.arc(3 * patternSize / 4, 3 * patternSize / 4, patternSize / 6, 0, Math.PI * 2);
                    pCtx.fill();
                    break;

                case 'checkerboard':
                    // Checkerboard
                    pCtx.fillStyle = color1;
                    pCtx.fillRect(0, 0, patternSize, patternSize);
                    pCtx.fillStyle = color2;
                    pCtx.fillRect(0, 0, patternSize / 2, patternSize / 2);
                    pCtx.fillRect(patternSize / 2, patternSize / 2, patternSize / 2, patternSize / 2);
                    break;

                case 'diagonal':
                    // Diagonal lines
                    pCtx.fillStyle = color1;
                    pCtx.fillRect(0, 0, patternSize, patternSize);
                    pCtx.strokeStyle = color2;
                    pCtx.lineWidth = patternSize / 8;
                    pCtx.beginPath();
                    pCtx.moveTo(0, 0);
                    pCtx.lineTo(patternSize, patternSize);
                    pCtx.moveTo(patternSize, 0);
                    pCtx.lineTo(0, patternSize);
                    pCtx.stroke();
                    break;

                case 'grid':
                    // Grid
                    pCtx.fillStyle = color1;
                    pCtx.fillRect(0, 0, patternSize, patternSize);
                    pCtx.strokeStyle = color2;
                    pCtx.lineWidth = patternSize / 16;
                    pCtx.beginPath();
                    pCtx.moveTo(0, patternSize / 2);
                    pCtx.lineTo(patternSize, patternSize / 2);
                    pCtx.moveTo(patternSize / 2, 0);
                    pCtx.lineTo(patternSize / 2, patternSize);
                    pCtx.stroke();
                    break;
            }

            return ctx.createPattern(patternCanvas, 'repeat');
        }

        // Update custom radius display
        function updateRadius() {
            const value = document.getElementById('borderRadius').value;
            document.getElementById('radiusValue').textContent = value + '%';
            generateFavicon();
        }

        // Update gradient angle display
        function updateAngleDisplay() {
            const value = document.getElementById('gradientAngle').value;
            document.getElementById('angleValue').textContent = value + '¬∞';
        }

        // Show/hide custom radius control
        function toggleShapeControls() {
            const shape = document.getElementById('shape').value;
            document.getElementById('customRadiusGroup').style.display = shape === 'custom' ? 'block' : 'none';
        }

        // Toggle shadow controls
        function toggleShadow() {
            const enabled = document.getElementById('enableShadow').checked;
            document.getElementById('shadowControls').style.display = enabled ? 'block' : 'none';
            generateFavicon();
        }

        // Update shadow blur display
        function updateShadowBlur() {
            const value = document.getElementById('shadowBlur').value;
            document.getElementById('shadowBlurValue').textContent = value + 'px';
            generateFavicon();
        }

        // Update shadow X offset display
        function updateShadowX() {
            const value = document.getElementById('shadowX').value;
            document.getElementById('shadowXValue').textContent = value + 'px';
            generateFavicon();
        }

        // Update shadow Y offset display
        function updateShadowY() {
            const value = document.getElementById('shadowY').value;
            document.getElementById('shadowYValue').textContent = value + 'px';
            generateFavicon();
        }

        // Generate favicon from text/emoji
        function generateFavicon() {
            if (currentInputMode !== 'text') return;

            const text = document.getElementById('textInput').value || 'F';
            const textColor = document.getElementById('textColor').value;
            const fontFamily = document.getElementById('fontFamily').value;
            const shape = document.getElementById('shape').value;
            const bgType = document.getElementById('bgType').value;

            // Background settings
            const bgColor = document.getElementById('bgColor').value;
            const gradientAngle = parseInt(document.getElementById('gradientAngle').value);
            updateAngleDisplay();

            toggleShapeControls();

            SIZES.forEach(size => {
                const canvas = document.getElementById(`preview${size}`);
                if (!canvas) return;
                const ctx = canvas.getContext('2d');

                ctx.clearRect(0, 0, size, size);

                // Background
                if (bgType === 'linear') {
                    const angleRad = (gradientAngle - 90) * Math.PI / 180;
                    const x1 = size / 2 + Math.cos(angleRad) * size / 2;
                    const y1 = size / 2 + Math.sin(angleRad) * size / 2;
                    const x2 = size / 2 - Math.cos(angleRad) * size / 2;
                    const y2 = size / 2 - Math.sin(angleRad) * size / 2;
                    const gradient = ctx.createLinearGradient(x1, y1, x2, y2);

                    // Add all color stops
                    gradientStops.forEach(stop => {
                        gradient.addColorStop(stop.position / 100, stop.color);
                    });

                    ctx.fillStyle = gradient;
                } else if (bgType === 'radial') {
                    const centerX = size / 2;
                    const centerY = size / 2;
                    const radius = size / 2;
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, radius);

                    // Add all color stops
                    gradientStops.forEach(stop => {
                        gradient.addColorStop(stop.position / 100, stop.color);
                    });

                    ctx.fillStyle = gradient;
                } else if (bgType === 'pattern') {
                    const patternType = document.getElementById('patternType').value;
                    const patternColor1 = document.getElementById('patternColor1').value;
                    const patternColor2 = document.getElementById('patternColor2').value;
                    const pattern = createPattern(ctx, size, patternType, patternColor1, patternColor2);
                    ctx.fillStyle = pattern;
                } else {
                    ctx.fillStyle = bgColor;
                }

                drawShape(ctx, size, shape);

                // Text
                ctx.fillStyle = textColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // Apply shadow if enabled
                const shadowEnabled = document.getElementById('enableShadow').checked;
                if (shadowEnabled) {
                    const shadowColor = document.getElementById('shadowColor').value;
                    const shadowBlur = parseInt(document.getElementById('shadowBlur').value);
                    const shadowX = parseInt(document.getElementById('shadowX').value);
                    const shadowY = parseInt(document.getElementById('shadowY').value);

                    // Scale shadow based on size
                    const scale = size / 64;
                    ctx.shadowColor = shadowColor;
                    ctx.shadowBlur = shadowBlur * scale;
                    ctx.shadowOffsetX = shadowX * scale;
                    ctx.shadowOffsetY = shadowY * scale;
                }

                // Adjust font size based on text length and canvas size
                let fontSize = size * 0.6;
                if (text.length === 2) fontSize = size * 0.45;
                if (text.length >= 3) fontSize = size * 0.35;

                ctx.font = `bold ${fontSize}px ${fontFamily}`;
                ctx.fillText(text, size / 2, size / 2 + (size * 0.05));

                // Reset shadow
                if (shadowEnabled) {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                }
            });

            // Update platform previews
            updatePlatformPreviews();
        }

        // Generate favicon from uploaded image
        function generateFromImage() {
            if (!uploadedImage || currentInputMode !== 'upload') return;

            const bgColor = document.getElementById('uploadBgColor').value;
            const shape = document.getElementById('uploadShape').value;

            SIZES.forEach(size => {
                const canvas = document.getElementById(`preview${size}`);
                const ctx = canvas.getContext('2d');

                ctx.clearRect(0, 0, size, size);

                // Background (for transparent images)
                ctx.fillStyle = bgColor;
                drawShape(ctx, size, shape);

                // Calculate scaling to fit image
                const scale = Math.min(size / uploadedImage.width, size / uploadedImage.height);
                const scaledWidth = uploadedImage.width * scale;
                const scaledHeight = uploadedImage.height * scale;
                const x = (size - scaledWidth) / 2;
                const y = (size - scaledHeight) / 2;

                // Clip to shape if needed
                if (shape === 'circle') {
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, scaledWidth, scaledHeight);
                    ctx.restore();
                } else if (shape === 'rounded') {
                    ctx.save();
                    const r = size * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(r, 0);
                    ctx.lineTo(size - r, 0);
                    ctx.quadraticCurveTo(size, 0, size, r);
                    ctx.lineTo(size, size - r);
                    ctx.quadraticCurveTo(size, size, size - r, size);
                    ctx.lineTo(r, size);
                    ctx.quadraticCurveTo(0, size, 0, size - r);
                    ctx.lineTo(0, r);
                    ctx.quadraticCurveTo(0, 0, r, 0);
                    ctx.clip();
                    ctx.drawImage(uploadedImage, x, y, scaledWidth, scaledHeight);
                    ctx.restore();
                } else {
                    ctx.drawImage(uploadedImage, x, y, scaledWidth, scaledHeight);
                }
            });

            // Update platform previews
            updatePlatformPreviews();
        }

        // Draw shape helper
        function drawShape(ctx, size, shape) {
            if (shape === 'circle') {
                ctx.beginPath();
                ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
                ctx.fill();
            } else if (shape === 'rounded') {
                const r = size * 0.2;
                ctx.beginPath();
                ctx.moveTo(r, 0);
                ctx.lineTo(size - r, 0);
                ctx.quadraticCurveTo(size, 0, size, r);
                ctx.lineTo(size, size - r);
                ctx.quadraticCurveTo(size, size, size - r, size);
                ctx.lineTo(r, size);
                ctx.quadraticCurveTo(0, size, 0, size - r);
                ctx.lineTo(0, r);
                ctx.quadraticCurveTo(0, 0, r, 0);
                ctx.fill();
            } else if (shape === 'hexagon') {
                // Draw hexagon
                const centerX = size / 2;
                const centerY = size / 2;
                const radius = size / 2;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (Math.PI / 3) * i - Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.fill();
            } else if (shape === 'custom') {
                // Custom border radius
                const radiusPercent = parseInt(document.getElementById('borderRadius').value) / 100;
                const r = size * radiusPercent;
                ctx.beginPath();
                ctx.moveTo(r, 0);
                ctx.lineTo(size - r, 0);
                ctx.quadraticCurveTo(size, 0, size, r);
                ctx.lineTo(size, size - r);
                ctx.quadraticCurveTo(size, size, size - r, size);
                ctx.lineTo(r, size);
                ctx.quadraticCurveTo(0, size, 0, size - r);
                ctx.lineTo(0, r);
                ctx.quadraticCurveTo(0, 0, r, 0);
                ctx.fill();
            } else {
                ctx.fillRect(0, 0, size, size);
            }
        }

        // Update platform preview mockups
        function updatePlatformPreviews() {
            // Browser tab preview (16x16)
            const browserTabCanvas = document.getElementById('previewBrowserTab');
            const preview16 = document.getElementById('preview16');
            if (browserTabCanvas && preview16) {
                const ctx = browserTabCanvas.getContext('2d');
                ctx.clearRect(0, 0, 16, 16);
                ctx.drawImage(preview16, 0, 0);
            }

            // iOS preview (180x180)
            const iosCanvas = document.getElementById('previewIOS');
            const preview180 = document.getElementById('preview180');
            if (iosCanvas && preview180) {
                const ctx = iosCanvas.getContext('2d');
                ctx.clearRect(0, 0, 180, 180);
                ctx.drawImage(preview180, 0, 0);
            }

            // Android preview (192x192)
            const androidCanvas = document.getElementById('previewAndroid');
            const preview192 = document.getElementById('preview192');
            if (androidCanvas && preview192) {
                const ctx = androidCanvas.getContext('2d');
                ctx.clearRect(0, 0, 192, 192);
                ctx.drawImage(preview192, 0, 0);
            }
        }

        // Download ZIP with all sizes
        async function downloadZip() {
            try {
                const zip = new JSZip();

                // Add all PNG sizes
                for (const size of SIZES) {
                    const canvas = document.getElementById(`preview${size}`);
                    if (!canvas) continue;
                    const blob = await new Promise(resolve => canvas.toBlob(resolve));
                    let filename;
                    if (size === 180) filename = 'apple-touch-icon.png';
                    else if (size === 192) filename = 'android-chrome-192x192.png';
                    else if (size === 512) filename = 'android-chrome-512x512.png';
                    else if (size === 256) filename = 'windows-tile-256x256.png';
                    else if (size === 128) filename = 'chrome-extension-128x128.png';
                    else if (size === 96) filename = 'google-tv-96x96.png';
                    else filename = `favicon-${size}x${size}.png`;
                    zip.file(filename, blob);
                }

                // Add favicon.ico
                const icoBlob = await generateIcoBlob();
                zip.file('favicon.ico', icoBlob);

                // Add SVG (if text mode)
                if (currentInputMode === 'text') {
                    const svgContent = generateSvg();
                    if (svgContent) {
                        zip.file('favicon.svg', svgContent);
                    }
                }

                // Add HTML instructions
                const htmlCode = document.getElementById('htmlCode').value;
                zip.file('README.txt', `Favicon Installation Instructions
=================================

1. Upload all files to your website's root directory
2. Add this HTML code to your <head> section:

${htmlCode}

3. Clear your browser cache and refresh to see the new favicon

Generated by Code Utils (https://codeutils.org/favicon-generator)
`);

                // Generate and download ZIP
                const content = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(content);
                link.download = 'favicons.zip';
                link.click();

                CodeUtils.Message.success('ZIP file downloaded with all favicon sizes!');
            } catch (error) {
                CodeUtils.Message.error('Error creating ZIP file: ' + error.message);
            }
        }

        // Download individual PNGs
        function downloadIndividual() {
            SIZES.forEach((size, index) => {
                setTimeout(() => {
                    const canvas = document.getElementById(`preview${size}`);
                    const link = document.createElement('a');
                    const filename = size === 180 ? 'apple-touch-icon.png' :
                                    size === 192 ? 'android-chrome-192x192.png' :
                                    size === 512 ? 'android-chrome-512x512.png' :
                                    `favicon-${size}x${size}.png`;
                    link.download = filename;
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                }, index * 150);
            });
            CodeUtils.Message.success('Downloading all favicon sizes...');
        }

        // Generate ICO blob (multi-size ICO file)
        async function generateIcoBlob() {
            // Create a simple ICO file with 16x16, 32x32, and 64x64
            const sizes = [16, 32, 64];
            const images = [];

            for (const size of sizes) {
                const canvas = document.getElementById(`preview${size}`);
                const imageData = await getImageData(canvas, size);
                images.push(imageData);
            }

            return createIcoFile(images);
        }

        // Get image data from canvas
        async function getImageData(canvas, size) {
            return new Promise((resolve) => {
                canvas.toBlob((blob) => {
                    const reader = new FileReader();
                    reader.onload = () => {
                        resolve({
                            size: size,
                            data: new Uint8Array(reader.result)
                        });
                    };
                    reader.readAsArrayBuffer(blob);
                });
            });
        }

        // Create ICO file from PNG images
        function createIcoFile(images) {
            // ICO header (6 bytes)
            const iconDirSize = 6 + (images.length * 16);
            let offset = iconDirSize;
            let totalSize = iconDirSize;

            images.forEach(img => {
                totalSize += img.data.length;
            });

            const buffer = new ArrayBuffer(totalSize);
            const view = new DataView(buffer);
            const bytes = new Uint8Array(buffer);

            // Write ICONDIR
            view.setUint16(0, 0, true); // Reserved
            view.setUint16(2, 1, true); // Type (1 = ICO)
            view.setUint16(4, images.length, true); // Number of images

            // Write ICONDIRENTRY for each image
            images.forEach((img, i) => {
                const entryOffset = 6 + (i * 16);
                view.setUint8(entryOffset + 0, img.size === 256 ? 0 : img.size); // Width
                view.setUint8(entryOffset + 1, img.size === 256 ? 0 : img.size); // Height
                view.setUint8(entryOffset + 2, 0); // Color palette
                view.setUint8(entryOffset + 3, 0); // Reserved
                view.setUint16(entryOffset + 4, 1, true); // Color planes
                view.setUint16(entryOffset + 6, 32, true); // Bits per pixel
                view.setUint32(entryOffset + 8, img.data.length, true); // Image size
                view.setUint32(entryOffset + 12, offset, true); // Image offset

                // Write image data
                bytes.set(img.data, offset);
                offset += img.data.length;
            });

            return new Blob([buffer], { type: 'image/x-icon' });
        }

        // Download ICO file
        async function downloadIco() {
            try {
                const blob = await generateIcoBlob();
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'favicon.ico';
                link.click();
                CodeUtils.Message.success('favicon.ico downloaded!');
            } catch (error) {
                CodeUtils.Message.error('Error creating ICO file: ' + error.message);
            }
        }

        // Generate SVG favicon
        function generateSvg() {
            if (currentInputMode !== 'text') {
                CodeUtils.Message.warning('SVG export only supports text/emoji mode');
                return null;
            }

            const text = document.getElementById('textInput').value || 'F';
            const textColor = document.getElementById('textColor').value;
            const fontFamily = document.getElementById('fontFamily').value;
            const shape = document.getElementById('shape').value;
            const bgType = document.getElementById('bgType').value;
            const size = 512;

            let svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 ${size} ${size}">`;

            // Background
            if (bgType === 'solid') {
                const bgColor = document.getElementById('bgColor').value;
                if (shape === 'circle') {
                    svgContent += `<circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="${bgColor}"/>`;
                } else {
                    const rx = shape === 'rounded' ? size * 0.1 : 0;
                    svgContent += `<rect width="${size}" height="${size}" rx="${rx}" fill="${bgColor}"/>`;
                }
            } else if (bgType === 'linear' || bgType === 'radial') {
                const gradientId = 'grad' + Date.now();
                const angle = parseInt(document.getElementById('gradientAngle').value);

                if (bgType === 'linear') {
                    const angleRad = (angle - 90) * Math.PI / 180;
                    const x1 = 50 + Math.cos(angleRad) * 50;
                    const y1 = 50 + Math.sin(angleRad) * 50;
                    const x2 = 50 - Math.cos(angleRad) * 50;
                    const y2 = 50 - Math.sin(angleRad) * 50;

                    svgContent += `<defs><linearGradient id="${gradientId}" x1="${x1}%" y1="${y1}%" x2="${x2}%" y2="${y2}%">`;
                    gradientStops.forEach(stop => {
                        svgContent += `<stop offset="${stop.position}%" stop-color="${stop.color}"/>`;
                    });
                    svgContent += `</linearGradient></defs>`;
                } else {
                    svgContent += `<defs><radialGradient id="${gradientId}">`;
                    gradientStops.forEach(stop => {
                        svgContent += `<stop offset="${stop.position}%" stop-color="${stop.color}"/>`;
                    });
                    svgContent += `</radialGradient></defs>`;
                }

                if (shape === 'circle') {
                    svgContent += `<circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="url(#${gradientId})"/>`;
                } else {
                    const rx = shape === 'rounded' ? size * 0.1 : 0;
                    svgContent += `<rect width="${size}" height="${size}" rx="${rx}" fill="url(#${gradientId})"/>`;
                }
            }

            // Text
            let fontSize = size * 0.6;
            if (text.length === 2) fontSize = size * 0.45;
            if (text.length >= 3) fontSize = size * 0.35;

            const shadowEnabled = document.getElementById('enableShadow').checked;
            let textElement = `<text x="${size/2}" y="${size/2 + fontSize * 0.35}" font-family="${fontFamily}" font-size="${fontSize}" font-weight="bold" text-anchor="middle" fill="${textColor}"`;

            if (shadowEnabled) {
                const shadowColor = document.getElementById('shadowColor').value;
                const shadowBlur = parseInt(document.getElementById('shadowBlur').value);
                const shadowX = parseInt(document.getElementById('shadowX').value);
                const shadowY = parseInt(document.getElementById('shadowY').value);
                const filterId = 'shadow' + Date.now();

                svgContent += `<defs><filter id="${filterId}"><feDropShadow dx="${shadowX}" dy="${shadowY}" stdDeviation="${shadowBlur}" flood-color="${shadowColor}"/></filter></defs>`;
                textElement += ` filter="url(#${filterId})"`;
            }

            textElement += `>${text}</text>`;
            svgContent += textElement;
            svgContent += '</svg>';

            return svgContent;
        }

        // Download SVG file
        function downloadSvg() {
            try {
                const svgContent = generateSvg();
                if (!svgContent) return;

                const blob = new Blob([svgContent], { type: 'image/svg+xml' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'favicon.svg';
                link.click();
                CodeUtils.Message.success('SVG favicon downloaded!');
            } catch (error) {
                CodeUtils.Message.error('Error creating SVG: ' + error.message);
            }
        }

        // Initialize on load
        init();
    </script>
</body>

</html>