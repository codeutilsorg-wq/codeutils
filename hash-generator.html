<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- CRITICAL: Apply theme immediately to prevent flash -->
    <script>
        (function() {
            const theme = localStorage.getItem('codeutils-theme');
            if (theme === 'light') {
                document.documentElement.classList.add('light-mode');
            }
        })();
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Generator | MD5, SHA-1, SHA-256, SHA-512 - Code Utils</title>
    <meta name="description" content="Generate MD5, SHA-1, SHA-256, SHA-512 hashes instantly. Auto-hash on input, copy results with one click. 100% private client-side processing. Start hashing now!">
    <meta name="keywords" content="hash generator, md5 generator, sha1 generator, sha256 generator, sha512 generator, hash calculator, checksum, developer tools">
    <link rel="canonical" href="https://codeutils.org/hash-generator">

    <!-- Favicon and Touch Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#3498db">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://codeutils.org/hash-generator">
    <meta property="og:title" content="Hash Generator - MD5, SHA-1, SHA-256, SHA-512 - Code Utils">
    <meta property="og:description" content="Generate cryptographic hashes instantly with MD5, SHA-1, SHA-256, and SHA-512 algorithms. 100% private client-side processing.">
    <meta property="og:image" content="https://codeutils.org/images/og/hash-generator.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="Hash Generator - Free online tool">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Hash Generator - MD5, SHA-1, SHA-256, SHA-512 - Code Utils">
    <meta name="twitter:description" content="Generate cryptographic hashes instantly. Free tool with auto-hash and 100% private processing.">
    <meta name="twitter:image" content="https://codeutils.org/images/og/hash-generator.png">

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">        <!-- Google Analytics (only load in production) -->
    <script>
        // Only load Google Analytics if NOT on localhost
        if (window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
            // Load gtag.js
            var script = document.createElement('script');
            script.async = true;
            script.src = 'https://www.googletagmanager.com/gtag/js?id=G-RPHPBJ4291';
            document.head.appendChild(script);

            // Initialize GA
            window.dataLayer = window.dataLayer || [];
            function gtag() { dataLayer.push(arguments); }
            gtag('js', new Date());
            gtag('config', 'G-RPHPBJ4291');
        } else {
            // Mock gtag function for localhost (prevents errors)
            window.gtag = function() {
                console.log('GA (localhost - not tracked):', arguments);
            };
        }
    </script>

    <!-- Structured Data: WebApplication Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Hash Generator - Code Utils",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free online hash generator for MD5, SHA-1, SHA-256, and SHA-512 algorithms. Generate cryptographic hashes with auto-hash on input. 100% client-side processing.",
      "url": "https://codeutils.org/hash-generator",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0"
    }
    </script>

    <!-- Structured Data: FAQ Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Which hash algorithm should I use for my application?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "SHA-256 is the recommended choice for most modern applications and provides a good balance between security and performance. Use SHA-256 for password hashing, file integrity verification, blockchain applications, and general security purposes. MD5 and SHA-1 are cryptographically broken and should only be used for non-security purposes like checksums. SHA-512 offers stronger security than SHA-256 but is slower and rarely needed unless you require maximum security for long-term data protection."
          }
        },
        {
          "@type": "Question",
          "name": "Can I reverse a hash to get the original text?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No, cryptographic hashes are one-way functions—they cannot be reversed to recover the original input. This is by design and is a fundamental security feature. The only way to 'crack' a hash is through brute force (trying many inputs) or using pre-computed hash tables called rainbow tables. This is why hashing is used for password storage—even if a database is compromised, the original passwords cannot be recovered from hashes."
          }
        },
        {
          "@type": "Question",
          "name": "What's the difference between MD5, SHA-1, SHA-256, and SHA-512?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "These are different cryptographic hash algorithms producing different hash lengths: MD5 produces 128-bit hashes (32 hex characters), SHA-1 produces 160-bit hashes (40 characters), SHA-256 produces 256-bit hashes (64 characters), and SHA-512 produces 512-bit hashes (128 characters). MD5 and SHA-1 are cryptographically broken and unsuitable for security. SHA-256 and SHA-512 are part of the SHA-2 family and remain secure. Generally, longer hashes provide stronger security against collisions."
          }
        },
        {
          "@type": "Question",
          "name": "Why should I use hashing instead of encryption?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Hashing and encryption serve different purposes. Use hashing when you need a one-way transformation (passwords, data verification), as hashes cannot be reversed. Use encryption when you need to decrypt the original data later. For passwords, hashing is essential because users can be verified without storing their actual password. For files, hashing verifies integrity—any change to the file produces a different hash, so you can detect tampering or corruption."
          }
        },
        {
          "@type": "Question",
          "name": "How do I verify file integrity using hashes?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "To verify file integrity, generate a hash of the file when it's created or received, then store that hash securely. Later, generate a new hash of the file and compare it to the stored hash. If the hashes match, the file hasn't been modified. If they differ, the file has been changed, corrupted, or tampered with. This is commonly used for software downloads, backups, and security-sensitive data. Use SHA-256 or higher for this purpose, not MD5 or SHA-1."
          }
        },
        {
          "@type": "Question",
          "name": "How do I use the hash verification feature?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Generate hashes for your text, then paste the expected hash (provided by a publisher or from a previous generation) into the Hash Verification field. The tool will automatically compare it against all generated hashes and show you a visual indicator: a green checkmark if there is a match, or a red X if no match is found. The matched algorithm will be highlighted with a green border. This is perfect for verifying downloaded files match publisher checksums, ensuring data has not been corrupted during transfer, or comparing hashes across different systems."
          }
        },
        {
          "@type": "Question",
          "name": "Can I choose which algorithms to compute?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! Use the Select Algorithms checkboxes at the top to choose which hash algorithms you want to compute (MD5, SHA-1, SHA-256, SHA-512). Unselected algorithms will not be computed, which saves processing time if you only need specific hashes. Your selection is automatically saved in your browser for future visits, so you do not have to reselect each time. This is a UNIQUE feature not found in other hash generators—perfect if you consistently use only SHA-256, for example."
          }
        },
        {
          "@type": "Question",
          "name": "What are rainbow tables and why do they matter?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Rainbow tables are pre-computed databases of hashes for common words, phrases, and passwords. Attackers use them to quickly 'crack' weak passwords by looking them up rather than computing hashes. This is why password hashing uses salt—a random value added to each password before hashing. Salting means each password's hash is unique, making rainbow tables useless. Modern password hashing algorithms like bcrypt and Argon2 include salting and slow computation, making them far more resistant to attacks than simple MD5 or SHA hashing."
          }
        }
      ]
    }
    </script>

    <link rel="stylesheet" href="css/common.css">
    <style>
        .hash-results { display: flex; flex-direction: column; gap: 15px; margin-top: var(--spacing-md); }
        .hash-item { background: var(--bg-secondary); border: 1px solid var(--border); padding: 15px; border-radius: var(--radius-sm); }
        .hash-label { font-weight: bold; color: var(--text-primary); margin-bottom: 8px; }
        .hash-output { display: flex; gap: 10px; align-items: center; }
        .hash-value { flex: 1; padding: 10px; background: var(--bg-white); border: 1px solid var(--border); font-family: 'Courier New', monospace; font-size: 13px; border-radius: var(--radius-sm); word-break: break-all; color: var(--text-primary); }

        /* Hash Verification Styles */
        .verification-result {
            margin-top: 12px;
            padding: 12px 16px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .verification-result.match {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .verification-result.no-match {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .verification-result.partial-match {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
        }
        .verification-icon {
            font-size: 20px;
            font-weight: bold;
        }
        .hash-item.matched {
            border: 2px solid #28a745;
            background: rgba(40, 167, 69, 0.05);
        }

        /* Algorithm Selection Styles */
        .algo-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--primary);
        }
        .hash-item.disabled {
            opacity: 0.4;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="header-logo">
                <h1>Code Utils</h1>
            </a>
            <nav class="header-nav">
                <a href="index.html" class="btn btn-outline btn-sm">All Tools</a>
                <button class="theme-toggle" onclick="CodeUtils.Theme.toggle()">Toggle Dark Mode</button>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="card" style="margin-bottom: var(--spacing-md); padding: var(--spacing-md);">
            <h2 style="margin-bottom: var(--spacing-xs); color: var(--primary);">Hash Generator</h2>
            <p style="margin: 0; color: var(--text-secondary);">Instantly generate cryptographic hashes using MD5, SHA-1, SHA-256, and SHA-512 algorithms. Hashing is essential for password storage, file integrity verification, blockchain applications, and data security. This tool generates hashes instantly with auto-hash on input for maximum convenience. Whether you're developing secure applications, verifying downloaded files, checking data integrity, or learning about cryptography, this tool provides all the hash algorithms you need. Real-time generation means you see results as you type, and one-click copy makes it easy to use hashes in your code or documentation. All processing happens completely securely in your browser—your data never leaves your computer. Perfect for developers, DevOps engineers, and security professionals.</p>
        </div>

        <div class="controls">
            <button class="btn" onclick="generateHashes()" title="Generate Hashes (Ctrl+Enter)">Generate Hashes</button>
            <button class="btn btn-outline" onclick="clearAll()">Clear</button>
        </div>

        <div id="message" class="message"></div>

        <!-- Algorithm Selection -->
        <div class="card" style="margin-bottom: var(--spacing-md);">
            <label style="font-weight: bold; display: block; margin-bottom: var(--spacing-sm); color: var(--text-primary);">
                Select Algorithms
                <span style="font-weight: normal; font-size: 0.875rem; color: var(--text-secondary); margin-left: 0.5rem;">
                    Choose which hash algorithms to compute (selection is saved)
                </span>
            </label>
            <div style="display: flex; gap: 24px; flex-wrap: wrap;">
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="algo-md5" class="algo-checkbox" value="md5" checked onchange="saveAlgorithmPreferences()">
                    <span style="color: var(--text-primary); font-size: 14px;">MD5</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="algo-sha1" class="algo-checkbox" value="sha1" checked onchange="saveAlgorithmPreferences()">
                    <span style="color: var(--text-primary); font-size: 14px;">SHA-1</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="algo-sha256" class="algo-checkbox" value="sha256" checked onchange="saveAlgorithmPreferences()">
                    <span style="color: var(--text-primary); font-size: 14px;">SHA-256</span>
                </label>
                <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
                    <input type="checkbox" id="algo-sha512" class="algo-checkbox" value="sha512" checked onchange="saveAlgorithmPreferences()">
                    <span style="color: var(--text-primary); font-size: 14px;">SHA-512</span>
                </label>
            </div>
        </div>

        <div class="card" style="margin-bottom: var(--spacing-md);">
            <label style="font-weight: bold; display: block; margin-bottom: var(--spacing-sm); color: var(--text-primary);">Input Text</label>
            <textarea id="input" class="editor" style="min-height: 150px;" placeholder="Enter text to generate hashes..."></textarea>
        </div>

        <!-- Hash Verification Section -->
        <div class="card" style="margin-bottom: var(--spacing-md);">
            <label style="font-weight: bold; display: block; margin-bottom: var(--spacing-xs); color: var(--text-primary);">
                Hash Verification (Optional)
                <span style="font-weight: normal; font-size: 0.875rem; color: var(--text-secondary); margin-left: 0.5rem;">
                    Compare generated hashes against expected checksums
                </span>
            </label>
            <input type="text" id="expectedHash" class="hash-verification-input"
                placeholder="Paste expected hash here (MD5, SHA-1, SHA-256, or SHA-512)..."
                oninput="verifyHash()"
                style="width: 100%; padding: 12px; border: 1px solid var(--border-color); border-radius: 4px; font-family: var(--font-mono); font-size: 14px; background: var(--bg-primary); color: var(--text-primary);">
            <div id="verificationResult" class="verification-result" style="display: none;"></div>
        </div>

        <div class="hash-results">
            <div class="hash-item">
                <div class="hash-label">MD5</div>
                <div class="hash-output">
                    <div class="hash-value" id="md5-output">-</div>
                    <button class="btn btn-sm btn-secondary" onclick="copyHash('md5')">Copy</button>
                </div>
            </div>
            <div class="hash-item">
                <div class="hash-label">SHA-1</div>
                <div class="hash-output">
                    <div class="hash-value" id="sha1-output">-</div>
                    <button class="btn btn-sm btn-secondary" onclick="copyHash('sha1')">Copy</button>
                </div>
            </div>
            <div class="hash-item">
                <div class="hash-label">SHA-256</div>
                <div class="hash-output">
                    <div class="hash-value" id="sha256-output">-</div>
                    <button class="btn btn-sm btn-secondary" onclick="copyHash('sha256')">Copy</button>
                </div>
            </div>
            <div class="hash-item">
                <div class="hash-label">SHA-512</div>
                <div class="hash-output">
                    <div class="hash-value" id="sha512-output">-</div>
                    <button class="btn btn-sm btn-secondary" onclick="copyHash('sha512')">Copy</button>
                </div>
            </div>
        </div>

        <!-- Related Tools -->
        <div class="related-tools">
            <h3>Related Tools</h3>
            <div class="related-tools-grid">
                <a href="base64-encoder.html" class="related-tool-card">
                    <span class="related-tool-icon">B64</span>
                    <span class="related-tool-name">Base64 Encoder</span>
                </a>
                <a href="url-encoder.html" class="related-tool-card">
                    <span class="related-tool-icon">%</span>
                    <span class="related-tool-name">URL Encoder</span>
                </a>
                <a href="html-encoder.html" class="related-tool-card">
                    <span class="related-tool-icon">&;</span>
                    <span class="related-tool-name">HTML Encoder</span>
                </a>
                <a href="json-formatter.html" class="related-tool-card">
                    <span class="related-tool-icon">{ }</span>
                    <span class="related-tool-name">JSON Formatter</span>
                </a>
            </div>
        </div>

        <!-- Info Section -->
        <div class="info-section">
            <h2>About Hash Generator</h2>
            <p>Cryptographic hashing is a fundamental technique in modern security, data integrity verification, and blockchain technology. This tool generates hashes instantly using four popular algorithms, with automatic generation as you type for maximum efficiency. Hashes are one-way functions that convert any input into a fixed-length string of characters, making them ideal for verifying data hasn't been modified, storing passwords securely, and detecting file corruption. Whether you're building secure applications, verifying downloads, or learning about cryptography, understanding hashes is essential for any developer.</p>

            <h3>Key Features</h3>
            <ul>
                <li><strong>Multiple Algorithms:</strong> Generate hashes using MD5, SHA-1, SHA-256, and SHA-512 algorithms simultaneously</li>
                <li><strong>Algorithm Selection:</strong> Choose which hash algorithms to compute using checkboxes—your preferences are automatically saved for future visits. This UNIQUE feature lets you focus only on the algorithms you need.</li>
                <li><strong>Auto-Hash on Input:</strong> Hashes are generated automatically as you type without needing to click a button</li>
                <li><strong>Real-Time Generation:</strong> Instant results with no delays or page reloads required</li>
                <li><strong>One-Click Copy:</strong> Copy individual hash values to clipboard for use in code or scripts</li>
                <li><strong>Hash Verification:</strong> Compare generated hashes against expected checksums with visual match indicators—perfect for verifying file downloads and data integrity</li>
                <li><strong>Algorithm Comparison:</strong> See all four algorithms side-by-side to compare hash lengths and formats</li>
                <li><strong>Clear Function:</strong> Reset input and all hash outputs with a single button</li>
                <li><strong>UTF-8 Support:</strong> Properly handles international characters, emoji, and special symbols</li>
                <li><strong>100% Client-Side:</strong> All hashing happens in your browser—your data never leaves your computer</li>
            </ul>

            <h3>How to Use This Tool</h3>

            <p><strong>Method 1: Auto-Hash on Input (Recommended)</strong></p>
            <ol>
                <li>Paste or type your text into the "Input Text" field</li>
                <li>Hashes for all four algorithms are generated automatically as you type</li>
                <li>View the MD5, SHA-1, SHA-256, and SHA-512 hashes in real-time below</li>
                <li>Click the "Copy" button on any hash to copy it to your clipboard</li>
                <li>Use the hashes in your code, documentation, or verification process</li>
            </ol>

            <p><strong>Method 2: Manual Hash Generation</strong></p>
            <ol>
                <li>Enter your text in the input field</li>
                <li>Click the "Generate Hashes" button (or press Ctrl+Enter) to generate all hashes</li>
                <li>Results appear in the hash output sections below</li>
                <li>Copy individual hashes as needed</li>
            </ol>

            <p><strong>Keyboard Shortcuts (Power Users)</strong></p>
            <ul>
                <li><strong>Ctrl + Enter</strong> - Generate hashes manually</li>
            </ul>

            <p><em>Pro tip: Use SHA-256 for most applications—it's secure, widely supported, and recommended by security experts. Avoid MD5 and SHA-1 for security purposes as they are cryptographically broken.</em></p>

            <h3>Common Use Cases</h3>

            <p><strong>Storing Passwords Securely</strong></p>
            <p>Never store passwords in plain text. Instead, hash the password when a user creates an account and store the hash. When the user logs in, hash their input password and compare it to the stored hash. If they match, the password is correct—but even if your database is compromised, attackers only get hashes, not actual passwords. For production applications, use specialized password hashing algorithms like bcrypt or Argon2 which include salt and slow computation to resist brute-force attacks.</p>

            <p><strong>Verifying File Integrity and Detecting Corruption</strong></p>
            <p>Generate a hash of a file when it's created or downloaded, then store it securely. Later, generate a new hash and compare—if they match, the file hasn't been modified or corrupted. If they differ, something changed. This is essential for software downloads (verify you got the correct file), backups (detect corruption), and security-sensitive documents. Any tiny change to a file produces a completely different hash, so this method reliably detects tampering.</p>

            <p><strong>Detecting Duplicate Data and Files</strong></p>
            <p>Computing hashes of files, records, or content allows you to quickly identify duplicates by comparing hashes instead of comparing entire datasets. In databases, you can use hashes to find duplicate records efficiently. In file systems, hash-based deduplication saves storage by identifying identical files. This is especially useful in large-scale systems where comparing full content would be slow.</p>

            <p><strong>Blockchain and Cryptocurrency Applications</strong></p>
            <p>Hashing is fundamental to blockchain technology where each block's hash is derived from its contents and the previous block's hash, creating an immutable chain. If someone tries to modify a block, its hash changes, breaking the chain and revealing the tampering. This is why blockchain is so secure. Cryptocurrencies use hashing extensively in proof-of-work algorithms and transaction verification.</p>

            <h3>Tips & Best Practices</h3>
            <ul>
                <li><strong>Use SHA-256 by default:</strong> SHA-256 is the recommended choice for most applications—it's secure, widely supported, and has good performance</li>
                <li><strong>Never use MD5 or SHA-1 for security:</strong> These algorithms are cryptographically broken. Only use them for non-security purposes like checksums or legacy system compatibility</li>
                <li><strong>Use salt for password hashing:</strong> Never hash passwords with plain algorithms. Use bcrypt, scrypt, or Argon2 which add salt and include slowdown to resist brute-force attacks</li>
                <li><strong>Hash consistently:</strong> Always use the same algorithm and encoding (UTF-8) when generating hashes you'll compare later</li>
                <li><strong>Longer hashes are stronger:</strong> SHA-512 provides stronger security than SHA-256 but is slower. Choose based on your security requirements</li>
                <li><strong>Hashing is not encryption:</strong> Hashes cannot be reversed. Use encryption if you need to retrieve the original data. Use hashing only for verification</li>
            </ul>

            <h3>Frequently Asked Questions</h3>

            <p><strong>Q: Which hash algorithm should I use for my application?</strong></p>
            <p>A: SHA-256 is the recommended choice for most modern applications and provides a good balance between security and performance. Use SHA-256 for password hashing, file integrity verification, blockchain applications, and general security purposes. MD5 and SHA-1 are cryptographically broken and should only be used for non-security purposes like checksums. SHA-512 offers stronger security than SHA-256 but is slower and rarely needed unless you require maximum security for long-term data protection.</p>

            <p><strong>Q: Can I reverse a hash to get the original text?</strong></p>
            <p>A: No, cryptographic hashes are one-way functions—they cannot be reversed to recover the original input. This is by design and is a fundamental security feature. The only way to 'crack' a hash is through brute force (trying many inputs) or using pre-computed hash tables called rainbow tables. This is why hashing is used for password storage—even if a database is compromised, the original passwords cannot be recovered from hashes.</p>

            <p><strong>Q: What's the difference between MD5, SHA-1, SHA-256, and SHA-512?</strong></p>
            <p>A: These are different cryptographic hash algorithms producing different hash lengths: MD5 produces 128-bit hashes (32 hex characters), SHA-1 produces 160-bit hashes (40 characters), SHA-256 produces 256-bit hashes (64 characters), and SHA-512 produces 512-bit hashes (128 characters). MD5 and SHA-1 are cryptographically broken and unsuitable for security. SHA-256 and SHA-512 are part of the SHA-2 family and remain secure. Generally, longer hashes provide stronger security against collisions.</p>

            <p><strong>Q: Why should I use hashing instead of encryption?</strong></p>
            <p>A: Hashing and encryption serve different purposes. Use hashing when you need a one-way transformation (passwords, data verification), as hashes cannot be reversed. Use encryption when you need to decrypt the original data later. For passwords, hashing is essential because users can be verified without storing their actual password. For files, hashing verifies integrity—any change to the file produces a different hash, so you can detect tampering or corruption.</p>

            <p><strong>Q: How do I verify file integrity using hashes?</strong></p>
            <p>A: To verify file integrity, generate a hash of the file when it's created or received, then store that hash securely. Later, generate a new hash of the file and compare it to the stored hash. If the hashes match, the file hasn't been modified. If they differ, the file has been changed, corrupted, or tampered with. This is commonly used for software downloads, backups, and security-sensitive data. Use SHA-256 or higher for this purpose, not MD5 or SHA-1.</p>

            <p><strong>Q: How do I use the hash verification feature?</strong></p>
            <p>A: Generate hashes for your text, then paste the expected hash (provided by a publisher or from a previous generation) into the "Hash Verification" field. The tool will automatically compare it against all generated hashes and show you a visual indicator: a green checkmark (✓) if there's a match, or a red X (✗) if no match is found. The matched algorithm will be highlighted with a green border. This is perfect for verifying downloaded files match publisher checksums, ensuring data hasn't been corrupted during transfer, or comparing hashes across different systems.</p>

            <p><strong>Q: Can I choose which algorithms to compute?</strong></p>
            <p>A: Yes! Use the "Select Algorithms" checkboxes at the top to choose which hash algorithms you want to compute (MD5, SHA-1, SHA-256, SHA-512). Unselected algorithms won't be computed, which saves processing time if you only need specific hashes. Your selection is automatically saved in your browser for future visits, so you don't have to reselect each time. This is a UNIQUE feature not found in other hash generators—perfect if you consistently use only SHA-256, for example.</p>

            <p><strong>Q: What are rainbow tables and why do they matter?</strong></p>
            <p>A: Rainbow tables are pre-computed databases of hashes for common words, phrases, and passwords. Attackers use them to quickly 'crack' weak passwords by looking them up rather than computing hashes. This is why password hashing uses salt—a random value added to each password before hashing. Salting means each password's hash is unique, making rainbow tables useless. Modern password hashing algorithms like bcrypt and Argon2 include salting and slow computation, making them far more resistant to attacks than simple MD5 or SHA hashing.</p>

            <h3>Hash Algorithm Specifications</h3>
            <p><strong>MD5 (Message Digest Algorithm 5):</strong> Produces 128-bit output (32 hex characters). Fast but cryptographically broken—collision attacks are practical. Avoid for security; use only for checksums or legacy compatibility. Output example: 5d41402abc4b2a76b9719d911017c592</p>
            <p><strong>SHA-1 (Secure Hash Algorithm 1):</strong> Produces 160-bit output (40 hex characters). Deprecated for security purposes—collision attacks have been demonstrated. Still used in Git and some legacy systems but should be replaced with SHA-256.</p>
            <p><strong>SHA-256 (SHA-2 Family):</strong> Produces 256-bit output (64 hex characters). Secure and widely used in modern applications, blockchain, and security protocols. Recommended for most use cases.</p>
            <p><strong>SHA-512 (SHA-2 Family):</strong> Produces 512-bit output (128 hex characters). More secure than SHA-256 with larger output. Slightly slower but provides enhanced security for high-sensitivity applications.</p>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 Code Utils. All rights reserved.</p>
        <p>Free developer utilities - 100% client-side processing</p>
    </footer>

    <script src="js/common.js"></script>
    <script>
        // Track this tool visit
        CodeUtils.RecentTools.add({
            id: 'hash-generator',
            name: 'Hash Generator',
            url: 'hash-generator.html'
        });

        const input = document.getElementById('input');
        CodeUtils.Message.init('message');

        // Algorithm Selection Functions
        function getSelectedAlgorithms() {
            const checkboxes = document.querySelectorAll('.algo-checkbox');
            const selected = [];
            checkboxes.forEach(cb => {
                if (cb.checked) {
                    selected.push(cb.value);
                }
            });
            return selected;
        }

        function saveAlgorithmPreferences() {
            const selected = getSelectedAlgorithms();
            localStorage.setItem('hashGeneratorAlgorithms', JSON.stringify(selected));
            updateHashVisibility();
        }

        function loadAlgorithmPreferences() {
            const saved = localStorage.getItem('hashGeneratorAlgorithms');
            if (saved) {
                try {
                    const selected = JSON.parse(saved);
                    // Uncheck all first
                    document.querySelectorAll('.algo-checkbox').forEach(cb => {
                        cb.checked = selected.includes(cb.value);
                    });
                } catch (e) {
                    // Invalid saved data, ignore
                }
            }
            updateHashVisibility();
        }

        function updateHashVisibility() {
            const selected = getSelectedAlgorithms();
            const hashItems = {
                'md5': document.querySelector('[id="md5-output"]').closest('.hash-item'),
                'sha1': document.querySelector('[id="sha1-output"]').closest('.hash-item'),
                'sha256': document.querySelector('[id="sha256-output"]').closest('.hash-item'),
                'sha512': document.querySelector('[id="sha512-output"]').closest('.hash-item')
            };

            // Show/hide hash result divs based on selection
            Object.keys(hashItems).forEach(algo => {
                if (selected.includes(algo)) {
                    hashItems[algo].classList.remove('disabled');
                    hashItems[algo].style.display = '';
                } else {
                    hashItems[algo].classList.add('disabled');
                    hashItems[algo].style.display = 'none';
                }
            });

            // Warn if no algorithms selected
            if (selected.length === 0) {
                CodeUtils.Message.warning('Please select at least one algorithm');
            }
        }

        async function generateHashes() {
            const inputValue = input.value;
            if (!inputValue) {
                CodeUtils.Message.error('Please enter text to hash');
                return;
            }

            const selected = getSelectedAlgorithms();
            if (selected.length === 0) {
                CodeUtils.Message.error('Please select at least one algorithm');
                return;
            }

            try {
                const encoder = new TextEncoder();
                const data = encoder.encode(inputValue);

                // Only compute selected algorithms
                if (selected.includes('md5')) {
                    const md5Hash = md5(inputValue);
                    document.getElementById('md5-output').textContent = md5Hash;
                }

                if (selected.includes('sha1')) {
                    const sha1Hash = await hashData('SHA-1', data);
                    document.getElementById('sha1-output').textContent = sha1Hash;
                }

                if (selected.includes('sha256')) {
                    const sha256Hash = await hashData('SHA-256', data);
                    document.getElementById('sha256-output').textContent = sha256Hash;
                }

                if (selected.includes('sha512')) {
                    const sha512Hash = await hashData('SHA-512', data);
                    document.getElementById('sha512-output').textContent = sha512Hash;
                }

                const algorithmNames = selected.map(a => a.toUpperCase()).join(', ');
                CodeUtils.Message.success(`${algorithmNames} hash${selected.length > 1 ? 'es' : ''} generated successfully!`);

                // Auto-verify if expected hash is already entered
                verifyHash();
            } catch (error) {
                CodeUtils.Message.error('Error generating hashes: ' + error.message);
            }
        }

        async function hashData(algorithm, data) {
            const hashBuffer = await crypto.subtle.digest(algorithm, data);
            return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // MD5 implementation
        function md5(string) {
            function rotateLeft(v, a) { return (v << a) | (v >>> (32 - a)); }
            function addUnsigned(x, y) { const lsw = (x & 0xFFFF) + (y & 0xFFFF); return ((x >> 16) + (y >> 16) + (lsw >> 16)) << 16 | (lsw & 0xFFFF); }
            function md5cmn(q, a, b, x, s, t) { return addUnsigned(rotateLeft(addUnsigned(addUnsigned(a, q), addUnsigned(x, t)), s), b); }
            function md5ff(a, b, c, d, x, s, t) { return md5cmn((b & c) | ((~b) & d), a, b, x, s, t); }
            function md5gg(a, b, c, d, x, s, t) { return md5cmn((b & d) | (c & (~d)), a, b, x, s, t); }
            function md5hh(a, b, c, d, x, s, t) { return md5cmn(b ^ c ^ d, a, b, x, s, t); }
            function md5ii(a, b, c, d, x, s, t) { return md5cmn(c ^ (b | (~d)), a, b, x, s, t); }

            string = string.replace(/\r\n/g, "\n");
            let utftext = "";
            for (let n = 0; n < string.length; n++) {
                const c = string.charCodeAt(n);
                if (c < 128) utftext += String.fromCharCode(c);
                else if (c > 127 && c < 2048) { utftext += String.fromCharCode((c >> 6) | 192); utftext += String.fromCharCode((c & 63) | 128); }
                else { utftext += String.fromCharCode((c >> 12) | 224); utftext += String.fromCharCode(((c >> 6) & 63) | 128); utftext += String.fromCharCode((c & 63) | 128); }
            }

            const x = [];
            for (let i = 0; i < utftext.length * 8; i += 8) x[i >> 5] |= (utftext.charCodeAt(i / 8) & 0xFF) << (i % 32);

            let [a, b, c, d] = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476];
            const xl = utftext.length * 8;
            x[xl >> 5] |= 0x80 << (xl % 32);
            x[(((xl + 64) >>> 9) << 4) + 14] = xl;

            for (let i = 0; i < x.length; i += 16) {
                const [olda, oldb, oldc, oldd] = [a, b, c, d];
                a = md5ff(a, b, c, d, x[i], 7, 0xD76AA478); d = md5ff(d, a, b, c, x[i+1], 12, 0xE8C7B756); c = md5ff(c, d, a, b, x[i+2], 17, 0x242070DB); b = md5ff(b, c, d, a, x[i+3], 22, 0xC1BDCEEE);
                a = md5ff(a, b, c, d, x[i+4], 7, 0xF57C0FAF); d = md5ff(d, a, b, c, x[i+5], 12, 0x4787C62A); c = md5ff(c, d, a, b, x[i+6], 17, 0xA8304613); b = md5ff(b, c, d, a, x[i+7], 22, 0xFD469501);
                a = md5ff(a, b, c, d, x[i+8], 7, 0x698098D8); d = md5ff(d, a, b, c, x[i+9], 12, 0x8B44F7AF); c = md5ff(c, d, a, b, x[i+10], 17, 0xFFFF5BB1); b = md5ff(b, c, d, a, x[i+11], 22, 0x895CD7BE);
                a = md5ff(a, b, c, d, x[i+12], 7, 0x6B901122); d = md5ff(d, a, b, c, x[i+13], 12, 0xFD987193); c = md5ff(c, d, a, b, x[i+14], 17, 0xA679438E); b = md5ff(b, c, d, a, x[i+15], 22, 0x49B40821);
                a = md5gg(a, b, c, d, x[i+1], 5, 0xF61E2562); d = md5gg(d, a, b, c, x[i+6], 9, 0xC040B340); c = md5gg(c, d, a, b, x[i+11], 14, 0x265E5A51); b = md5gg(b, c, d, a, x[i], 20, 0xE9B6C7AA);
                a = md5gg(a, b, c, d, x[i+5], 5, 0xD62F105D); d = md5gg(d, a, b, c, x[i+10], 9, 0x02441453); c = md5gg(c, d, a, b, x[i+15], 14, 0xD8A1E681); b = md5gg(b, c, d, a, x[i+4], 20, 0xE7D3FBC8);
                a = md5gg(a, b, c, d, x[i+9], 5, 0x21E1CDE6); d = md5gg(d, a, b, c, x[i+14], 9, 0xC33707D6); c = md5gg(c, d, a, b, x[i+3], 14, 0xF4D50D87); b = md5gg(b, c, d, a, x[i+8], 20, 0x455A14ED);
                a = md5gg(a, b, c, d, x[i+13], 5, 0xA9E3E905); d = md5gg(d, a, b, c, x[i+2], 9, 0xFCEFA3F8); c = md5gg(c, d, a, b, x[i+7], 14, 0x676F02D9); b = md5gg(b, c, d, a, x[i+12], 20, 0x8D2A4C8A);
                a = md5hh(a, b, c, d, x[i+5], 4, 0xFFFA3942); d = md5hh(d, a, b, c, x[i+8], 11, 0x8771F681); c = md5hh(c, d, a, b, x[i+11], 16, 0x6D9D6122); b = md5hh(b, c, d, a, x[i+14], 23, 0xFDE5380C);
                a = md5hh(a, b, c, d, x[i+1], 4, 0xA4BEEA44); d = md5hh(d, a, b, c, x[i+4], 11, 0x4BDECFA9); c = md5hh(c, d, a, b, x[i+7], 16, 0xF6BB4B60); b = md5hh(b, c, d, a, x[i+10], 23, 0xBEBFBC70);
                a = md5hh(a, b, c, d, x[i+13], 4, 0x289B7EC6); d = md5hh(d, a, b, c, x[i], 11, 0xEAA127FA); c = md5hh(c, d, a, b, x[i+3], 16, 0xD4EF3085); b = md5hh(b, c, d, a, x[i+6], 23, 0x04881D05);
                a = md5hh(a, b, c, d, x[i+9], 4, 0xD9D4D039); d = md5hh(d, a, b, c, x[i+12], 11, 0xE6DB99E5); c = md5hh(c, d, a, b, x[i+15], 16, 0x1FA27CF8); b = md5hh(b, c, d, a, x[i+2], 23, 0xC4AC5665);
                a = md5ii(a, b, c, d, x[i], 6, 0xF4292244); d = md5ii(d, a, b, c, x[i+7], 10, 0x432AFF97); c = md5ii(c, d, a, b, x[i+14], 15, 0xAB9423A7); b = md5ii(b, c, d, a, x[i+5], 21, 0xFC93A039);
                a = md5ii(a, b, c, d, x[i+12], 6, 0x655B59C3); d = md5ii(d, a, b, c, x[i+3], 10, 0x8F0CCC92); c = md5ii(c, d, a, b, x[i+10], 15, 0xFFEFF47D); b = md5ii(b, c, d, a, x[i+1], 21, 0x85845DD1);
                a = md5ii(a, b, c, d, x[i+8], 6, 0x6FA87E4F); d = md5ii(d, a, b, c, x[i+15], 10, 0xFE2CE6E0); c = md5ii(c, d, a, b, x[i+6], 15, 0xA3014314); b = md5ii(b, c, d, a, x[i+13], 21, 0x4E0811A1);
                a = md5ii(a, b, c, d, x[i+4], 6, 0xF7537E82); d = md5ii(d, a, b, c, x[i+11], 10, 0xBD3AF235); c = md5ii(c, d, a, b, x[i+2], 15, 0x2AD7D2BB); b = md5ii(b, c, d, a, x[i+9], 21, 0xEB86D391);
                a = addUnsigned(a, olda); b = addUnsigned(b, oldb); c = addUnsigned(c, oldc); d = addUnsigned(d, oldd);
            }

            const wordToHex = v => Array.from({length: 4}, (_, i) => ((v >> (i * 8)) & 0xFF).toString(16).padStart(2, '0')).join('');
            return wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
        }

        async function copyHash(algorithm) {
            const hashValue = document.getElementById(algorithm + '-output').textContent;
            if (hashValue === '-') {
                CodeUtils.Message.error('Generate hashes first');
                return;
            }
            try {
                await CodeUtils.Clipboard.copy(hashValue);
                CodeUtils.Message.success(algorithm.toUpperCase() + ' hash copied!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        function clearAll() {
            input.value = '';
            document.getElementById('expectedHash').value = '';
            ['md5', 'sha1', 'sha256', 'sha512'].forEach(alg => {
                document.getElementById(alg + '-output').textContent = '-';
                document.querySelector(`#${alg}-output`).parentElement.parentElement.classList.remove('matched');
            });
            document.getElementById('verificationResult').style.display = 'none';
            CodeUtils.Message.hide();
        }

        // Hash Verification Function
        function verifyHash() {
            const expectedHashInput = document.getElementById('expectedHash');
            const verificationResult = document.getElementById('verificationResult');
            const expectedHash = expectedHashInput.value.trim().toLowerCase();

            // Hide verification result if input is empty
            if (!expectedHash) {
                verificationResult.style.display = 'none';
                // Remove all matched highlights
                ['md5', 'sha1', 'sha256', 'sha512'].forEach(alg => {
                    document.querySelector(`#${alg}-output`).parentElement.parentElement.classList.remove('matched');
                });
                return;
            }

            // Get all generated hashes
            const hashes = {
                'md5': document.getElementById('md5-output').textContent,
                'sha1': document.getElementById('sha1-output').textContent,
                'sha256': document.getElementById('sha256-output').textContent,
                'sha512': document.getElementById('sha512-output').textContent
            };

            // Check if any hashes have been generated
            const hasGeneratedHashes = Object.values(hashes).some(h => h !== '-');
            if (!hasGeneratedHashes) {
                verificationResult.innerHTML = '<span class="verification-icon">ℹ️</span><span>Generate hashes first to verify</span>';
                verificationResult.className = 'verification-result partial-match';
                verificationResult.style.display = 'flex';
                return;
            }

            // Check for matches
            let matchedAlgorithm = null;
            let matchCount = 0;

            // Remove all previous matched highlights
            ['md5', 'sha1', 'sha256', 'sha512'].forEach(alg => {
                document.querySelector(`#${alg}-output`).parentElement.parentElement.classList.remove('matched');
            });

            Object.entries(hashes).forEach(([algorithm, hash]) => {
                if (hash !== '-' && hash.toLowerCase() === expectedHash) {
                    matchedAlgorithm = algorithm;
                    matchCount++;
                    // Highlight the matched hash
                    document.querySelector(`#${algorithm}-output`).parentElement.parentElement.classList.add('matched');
                }
            });

            // Display verification result
            if (matchCount > 0) {
                const algorithmName = matchedAlgorithm.toUpperCase();
                verificationResult.innerHTML = `<span class="verification-icon">✓</span><span><strong>Hash Match!</strong> Expected hash matches ${algorithmName}</span>`;
                verificationResult.className = 'verification-result match';
                verificationResult.style.display = 'flex';
            } else {
                verificationResult.innerHTML = '<span class="verification-icon">✗</span><span><strong>No Match</strong> - Expected hash does not match any generated hashes</span>';
                verificationResult.className = 'verification-result no-match';
                verificationResult.style.display = 'flex';
            }
        }

        CodeUtils.Shortcuts.register('Enter', generateHashes, true);

        // Auto-generate on input
        let debounceTimer;
        input.addEventListener('input', () => {
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => { if (input.value) generateHashes(); }, 500);
        });

        // Load algorithm preferences on page load
        loadAlgorithmPreferences();
    </script>
</body>
</html>
