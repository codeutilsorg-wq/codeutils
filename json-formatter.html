<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Free JSON Formatter & Validator | Format, Compare & Repair - Code Utils</title>
    <meta name="description"
        content="Free JSON formatter, validator & minifier. Features tree view, JSONPath queries, auto-repair, and diff comparison. 100% private - no data uploads.">
    <link rel="canonical" href="https://codeutils.org/json-formatter">

    <!-- Favicon and Touch Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#3498db">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://codeutils.org/json-formatter">
    <meta property="og:title" content="Free JSON Formatter & Validator - Code Utils">
    <meta property="og:description"
        content="Format, validate, and minify JSON instantly. 100% private client-side processing - your data never leaves your browser.">
    <meta property="og:image" content="https://codeutils.org/images/og/json-formatter.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="JSON Formatter - Free online JSON formatting tool">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="JSON Formatter & Validator - Code Utils">
    <meta name="twitter:description"
        content="Format, validate, and minify JSON instantly. Free tool with 100% private client-side processing.">
    <meta name="twitter:image" content="https://codeutils.org/images/og/json-formatter.png">

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RPHPBJ4291"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'G-RPHPBJ4291');
    </script>

    <!-- Structured Data: WebApplication Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "JSON Formatter - Code Utils",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free JSON formatter, validator, and minifier with customizable indentation, key sorting, and detailed error messages. Format, validate, minify, and sort JSON data. 100% client-side processing.",
      "url": "https://codeutils.org/json-formatter",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0"
    }
    </script>

    <!-- Structured Data: FAQ Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Is my data safe when using this tool?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes, absolutely! All JSON processing happens entirely in your browser using JavaScript. Your data never leaves your computer and is never uploaded to any server. We don't store, log, or transmit your JSON data in any way. This makes our tool completely safe for sensitive data like API keys, configuration files, or proprietary information. You can even use this tool offline after the initial page load."
          }
        },
        {
          "@type": "Question",
          "name": "Do I need to create an account or sign up?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No! All our tools are completely free and don't require any registration, sign-up, or account creation. Just visit the page and start using the JSON formatter immediately. There are no limits on usage, no premium tiers, and no hidden fees."
          }
        },
        {
          "@type": "Question",
          "name": "Can I use this tool offline?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! After you load the page for the first time, the tool can work offline because all processing happens in your browser. Your browser may cache the page, allowing you to use it without an internet connection. This is particularly useful when working in environments with restricted internet access or when traveling."
          }
        },
        {
          "@type": "Question",
          "name": "What are the file size limits?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Files under 2MB work perfectly with instant processing. Files between 2-5MB will work but may take slightly longer to process. Files between 5-10MB will show a performance warning but should still work. Files over 10MB may cause browser performance issues or slow down significantly, as the entire file must be processed in browser memory."
          }
        },
        {
          "@type": "Question",
          "name": "Is this tool really free forever?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! All our tools are 100% free with no hidden costs, premium tiers, or paid features. We may add optional ads in the future to support hosting costs, but the core functionality will always remain free. We believe developer tools should be accessible to everyone."
          }
        },
        {
          "@type": "Question",
          "name": "What's the difference between formatting and minifying JSON?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Formatting (also called beautifying) adds whitespace, newlines, and indentation to make JSON human-readable. It's ideal for development, debugging, and documentation. Minifying removes all unnecessary whitespace, newlines, and indentation to reduce file size. Minified JSON is harder to read but loads faster and uses less bandwidth, making it ideal for production environments, API responses, and storage optimization. Both versions contain identical data - only the formatting differs."
          }
        },
        {
          "@type": "Question",
          "name": "Can I customize the indentation level?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! You can choose between 2 spaces, 4 spaces, or tabs for indentation. Your preference is saved automatically so it persists across sessions. Just use the Indent dropdown in the toolbar to select your preferred style."
          }
        },
        {
          "@type": "Question",
          "name": "How do I sort JSON keys alphabetically?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Click the 'Sort Keys' button or press Ctrl+S to sort all object keys alphabetically. This works recursively on nested objects too. Sorting keys makes it easier to compare JSON files and maintain consistent formatting across your codebase."
          }
        },
        {
          "@type": "Question",
          "name": "What is the Tree View mode?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Tree View displays your JSON as an interactive, collapsible hierarchy. Click on objects or arrays to expand/collapse them, making it easy to navigate large JSON structures. Each value type is color-coded (strings, numbers, booleans, null) for quick identification. Toggle between Text and Tree view using the buttons above the output."
          }
        },
        {
          "@type": "Question",
          "name": "How do I search within my JSON?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Use the search box above the output area. Type your search term and matches will be highlighted. Press Enter to jump to the next match, or Shift+Enter to go to the previous match. The counter shows which match you're on (e.g., '3/15' means you're on match 3 of 15)."
          }
        }
      ]
    }
    </script>

    <!-- Structured Data: Breadcrumb Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      "itemListElement": [
        {
          "@type": "ListItem",
          "position": 1,
          "name": "Home",
          "item": "https://codeutils.org/"
        },
        {
          "@type": "ListItem",
          "position": 2,
          "name": "Formatters",
          "item": "https://codeutils.org/#formatters"
        },
        {
          "@type": "ListItem",
          "position": 3,
          "name": "JSON Formatter"
        }
      ]
    }
    </script>

    <!-- Structured Data: HowTo Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "HowTo",
      "name": "How to Format JSON Online",
      "description": "Learn how to format, validate, and minify JSON using our free online JSON formatter tool",
      "step": [
        {
          "@type": "HowToStep",
          "position": 1,
          "name": "Paste JSON Data",
          "text": "Copy your JSON data from your API response, file, or code editor and paste it into the Input JSON text area"
        },
        {
          "@type": "HowToStep",
          "position": 2,
          "name": "Click Format Button",
          "text": "Click the Format button to beautify your JSON with proper indentation, or click Minify to compact it"
        },
        {
          "@type": "HowToStep",
          "position": 3,
          "name": "Copy Formatted Output",
          "text": "The formatted JSON appears in the Output area. Use the Copy button to copy it to your clipboard"
        }
      ]
    }
    </script>

    <link rel="stylesheet" href="css/common.css">
    <style>
        /* View Mode Buttons */
        .view-mode-btn {
            padding: 4px 10px;
            border: none;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .view-mode-btn:hover {
            background: var(--border);
        }

        .view-mode-btn.active {
            background: var(--primary);
            color: white;
        }

        /* JSON Tree View */
        .json-tree {
            font-family: 'Courier New', Consolas, monospace;
            font-size: 14px;
            line-height: 1.5;
        }

        .tree-node {
            padding-left: 20px;
            position: relative;
        }

        .tree-node-header {
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .tree-node-header:hover {
            background: var(--primary-light);
        }

        .tree-toggle {
            width: 16px;
            height: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: var(--text-secondary);
            transition: transform 0.15s ease;
        }

        .tree-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .tree-key {
            color: #a71d5d;
        }

        .dark-mode .tree-key {
            color: #f97583;
        }

        .tree-value-string {
            color: #183691;
        }

        .dark-mode .tree-value-string {
            color: #9ecbff;
        }

        .tree-value-number {
            color: #0086b3;
        }

        .dark-mode .tree-value-number {
            color: #79b8ff;
        }

        .tree-value-boolean {
            color: #a71d5d;
        }

        .dark-mode .tree-value-boolean {
            color: #f97583;
        }

        .tree-value-null {
            color: #999;
        }

        .tree-bracket {
            color: var(--text-secondary);
        }

        .tree-children {
            overflow: hidden;
            transition: max-height 0.2s ease;
        }

        .tree-children.collapsed {
            display: none;
        }

        .tree-comma {
            color: var(--text-secondary);
        }

        .tree-count {
            color: var(--text-light);
            font-size: 12px;
            margin-left: 4px;
        }

        /* Search Highlighting */
        .search-match {
            background: #fff3cd;
            border-radius: 2px;
        }

        .dark-mode .search-match {
            background: #4d3d1a;
        }

        .search-active {
            background: #ffc107;
        }

        .dark-mode .search-active {
            background: #ffab00;
            color: #000;
        }

        /* Syntax Highlighted Output */
        .syntax-output {
            font-family: 'Courier New', Consolas, monospace;
            font-size: 14px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>

<body>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="header-logo">
                <h1>Code Utils</h1>
            </a>
            <nav class="header-nav">
                <a href="index.html" class="btn btn-outline btn-sm">All Tools</a>
                <button class="theme-toggle" onclick="CodeUtils.Theme.toggle()">Toggle Dark Mode</button>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="card" style="margin-bottom: var(--spacing-md); padding: var(--spacing-md);">
            <h2 style="margin-bottom: var(--spacing-xs); color: var(--primary);">Free JSON Formatter & Validator</h2>
            <div style="background: var(--bg-secondary); padding: 16px; border-left: 4px solid var(--primary); border-radius: 4px; margin-bottom: var(--spacing-md);">
                <strong style="color: var(--primary);">Quick Answer:</strong>
                <span style="color: var(--text-primary);">A JSON formatter beautifies minified JSON with proper indentation, validates syntax, and provides error detection. All processing happens in your browser - no data upload required.</span>
            </div>
            <p style="margin: 0; color: var(--text-secondary);">Instantly format, validate, and minify JSON data with
                our free online tool. Perfect for debugging API responses, editing configuration files, and preparing
                JSON for production. Features include real-time validation, syntax error detection, one-click copying,
                and file upload support. All processing happens securely in your browser - your data stays private and
                never touches our servers.</p>
        </div>

        <div class="drop-zone" id="dropZone">
            Drop JSON file here or click Upload File button
        </div>

        <div class="controls">
            <div class="controls-group">
                <button class="btn" onclick="formatJSON()" title="Format JSON (Ctrl+Enter)">Format</button>
                <button class="btn" onclick="minifyJSON()" title="Minify JSON (Ctrl+M)">Minify</button>
                <button class="btn" onclick="validateJSON()">Validate</button>
                <button class="btn" onclick="sortAndFormat()" title="Sort keys alphabetically (Ctrl+S)">Sort
                    Keys</button>
                <button class="btn" onclick="repairJSON()" title="Auto-fix common JSON errors">Repair</button>
            </div>
            <div class="controls-group">
                <label
                    style="display: flex; align-items: center; gap: 8px; font-size: 14px; color: var(--text-secondary);">
                    Indent:
                    <select id="indentSize"
                        style="padding: 6px 10px; border: 1px solid var(--border); border-radius: 3px; background: var(--bg-white); color: var(--text-primary); font-size: 14px; cursor: pointer;">
                        <option value="2">2 spaces</option>
                        <option value="4">4 spaces</option>
                        <option value="tab">Tab</option>
                    </select>
                </label>
            </div>
            <div class="controls-group">
                <button class="btn btn-secondary" onclick="copyOutput()" title="Copy Output (Ctrl+K)">Copy</button>
                <label for="fileUpload" class="btn btn-secondary" style="margin: 0;">Upload</label>
                <input type="file" id="fileUpload" class="file-upload" accept=".json,application/json,text/plain">
                <button class="btn btn-secondary" onclick="downloadJSON()">Download</button>
            </div>
            <button class="btn btn-outline" onclick="clearAll()">Clear</button>
        </div>

        <!-- Advanced Controls Row -->
        <div class="controls" style="margin-top: 8px;">
            <div class="controls-group" style="flex: 1;">
                <input type="text" id="urlInput" placeholder="Enter JSON URL to load..."
                    style="flex: 1; padding: 8px 12px; border: 1px solid var(--border); border-radius: 3px; font-size: 14px; background: var(--bg-white); color: var(--text-primary); min-width: 200px;">
                <button class="btn btn-secondary" onclick="loadFromURL()">Load URL</button>
            </div>
            <div class="controls-group" style="flex: 1;">
                <input type="text" id="jsonPathInput" placeholder="$.path.to.value (JSONPath query)"
                    style="flex: 1; padding: 8px 12px; border: 1px solid var(--border); border-radius: 3px; font-size: 14px; font-family: var(--font-mono); background: var(--bg-white); color: var(--text-primary); min-width: 200px;">
                <button class="btn btn-secondary" onclick="queryJSONPath()">Query</button>
            </div>
            <button class="btn btn-secondary" onclick="toggleDiffMode()" id="diffModeBtn">Compare</button>
        </div>

        <div id="message" class="message"></div>

        <div class="editor-container">
            <div class="editor-section">
                <div class="editor-header">Input JSON</div>
                <textarea id="inputJSON" class="editor" placeholder="Paste your JSON here..."></textarea>
            </div>
            <div class="editor-section">
                <div class="editor-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>Output</span>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="text" id="searchInput" placeholder="Search..."
                            style="padding: 4px 8px; border: 1px solid var(--border); border-radius: 3px; font-size: 12px; width: 120px; background: var(--bg-white); color: var(--text-primary);">
                        <span id="searchCount"
                            style="font-size: 11px; color: var(--text-light); min-width: 50px;"></span>
                        <div
                            style="display: flex; border: 1px solid var(--border); border-radius: 3px; overflow: hidden;">
                            <button class="view-mode-btn active" id="textViewBtn" onclick="setViewMode('text')"
                                title="Text View">Text</button>
                            <button class="view-mode-btn" id="treeViewBtn" onclick="setViewMode('tree')"
                                title="Tree View">Tree</button>
                        </div>
                    </div>
                </div>
                <div id="outputContainer" style="flex: 1; min-height: 400px; position: relative;">
                    <textarea id="outputJSON" class="editor" readonly placeholder="Formatted JSON will appear here..."
                        style="width: 100%; height: 100%; position: absolute; top: 0; left: 0;"></textarea>
                    <div id="treeView" class="json-tree"
                        style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; overflow: auto; padding: 16px; background: var(--bg-white);">
                    </div>
                </div>
            </div>
        </div>

        <!-- Related Tools -->
        <div class="related-tools">
            <h3>Related Tools</h3>
            <ul class="related-tools-list">
                <li><a href="xml-formatter.html">XML Formatter</a></li>
                <li><a href="base64-encoder.html">Base64 Encoder</a></li>
                <li><a href="url-encoder.html">URL Encoder</a></li>
                <li><a href="hash-generator.html">Hash Generator</a></li>
                <li><a href="timestamp-converter.html">Timestamp Converter</a></li>
            </ul>
        </div>

        <!-- Info Section -->
        <div class="info-section">
            <h2>About JSON Formatter</h2>
            <p>JSON (JavaScript Object Notation) is the most widely used data format for APIs, configuration files, and
                data exchange between systems. However, JSON data is often minified or poorly formatted, making it
                difficult to read and debug. Our JSON Formatter tool instantly beautifies minified JSON, validates
                syntax errors, and provides clear error messages to help you quickly identify and fix issues. Whether
                you're debugging API responses, editing configuration files, or preparing JSON for production, this tool
                provides everything you need in one place. All processing happens entirely in your browser using
                JavaScript, ensuring your sensitive data remains private and never touches our servers.</p>

            <h3>Key Features</h3>
            <ul>
                <li><strong>Format JSON:</strong> Beautify minified or compact JSON with proper indentation for easy
                    reading</li>
                <li><strong>Minify JSON:</strong> Remove all unnecessary whitespace and newlines to create compact JSON
                    for production use</li>
                <li><strong>Validate JSON:</strong> Check if your JSON syntax is valid and receive detailed error
                    messages with line and column numbers</li>
                <li><strong>Sort Keys:</strong> Sort all object keys alphabetically (recursively for nested objects) -
                    perfect for consistent formatting and easier comparisons</li>
                <li><strong>Customizable Indentation:</strong> Choose between 2 spaces, 4 spaces, or tabs - your
                    preference is saved automatically</li>
                <li><strong>Detailed Error Messages:</strong> Get precise error locations with line and column numbers
                    for quick debugging</li>
                <li><strong>File Support:</strong> Upload JSON files directly or drag and drop files into the browser
                </li>
                <li><strong>Download Output:</strong> Save formatted or minified JSON as a .json file to your computer
                </li>
                <li><strong>One-Click Copy:</strong> Quickly copy formatted output to clipboard for use in your code
                    editor</li>
                <li><strong>Real-Time Processing:</strong> Instant formatting without page reloads or delays</li>
                <li><strong>Privacy First:</strong> 100% client-side processing - your data never leaves your browser
                </li>
            </ul>

            <h3>How to Use This Tool</h3>

            <p><strong>Method 1: Paste JSON Directly</strong></p>
            <ol>
                <li>Copy your JSON data from your API response, file, or code editor</li>
                <li>Paste it into the "Input JSON" text area on the left side</li>
                <li>Click the "Format" button to beautify or "Minify" button to compact your JSON</li>
                <li>The formatted output appears instantly in the "Output" area on the right</li>
                <li>Use the "Copy" button to copy the result to your clipboard</li>
            </ol>

            <p><strong>Method 2: Upload a JSON File</strong></p>
            <ol>
                <li>Click the "Upload" button or drag and drop your .json file into the designated area</li>
                <li>The file content will automatically load into the input area</li>
                <li>Format or minify as needed, then download the result using the "Download" button</li>
            </ol>

            <p><strong>Keyboard Shortcuts (Power Users)</strong></p>
            <ul>
                <li><strong>Ctrl + Enter</strong> - Format JSON with proper indentation</li>
                <li><strong>Ctrl + M</strong> - Minify JSON to remove whitespace</li>
                <li><strong>Ctrl + K</strong> - Copy output to clipboard</li>
                <li><strong>Ctrl + S</strong> - Sort keys alphabetically and format</li>
            </ul>

            <p><em>Tip: The "Validate" button checks your JSON for syntax errors without formatting. If there's an
                    error, you'll see a detailed message indicating exactly what's wrong and where the error
                    occurs.</em></p>

            <h3>Common Use Cases</h3>

            <p><strong>Debugging API Responses</strong></p>
            <p>When testing APIs, responses are often returned as minified JSON to reduce bandwidth. Before you can
                understand the data structure or debug issues, you need to format it properly. Paste your API response
                into this tool to instantly see the hierarchy, nested objects, and array structures clearly formatted
                with proper indentation. This makes it much easier to identify missing fields, incorrect data types, or
                unexpected values.</p>

            <p><strong>Editing Configuration Files</strong></p>
            <p>Many applications use JSON for configuration files (package.json, tsconfig.json, settings.json, etc.).
                When editing these files manually, it's easy to introduce syntax errors like missing commas, unclosed
                brackets, or invalid quotes. Use this tool to validate your configuration before saving it, preventing
                runtime errors and application crashes caused by malformed JSON.</p>

            <p><strong>Preparing JSON for Production</strong></p>
            <p>When deploying applications, you often want to minify JSON files to reduce file size and improve load
                times. Configuration files, data fixtures, and static JSON resources can all be minified to remove
                unnecessary whitespace. Use the "Minify" feature to create compact JSON that's optimized for production
                while keeping a formatted version for development and debugging.</p>

            <p><strong>Learning and Teaching JSON Structure</strong></p>
            <p>If you're learning JSON or teaching others about data structures, proper formatting is essential for
                understanding. Format complex JSON examples to clearly show object nesting, array structures, key-value
                pairs, and data types. The clear visual hierarchy makes it easier to explain concepts like nested
                objects, arrays of objects, and proper JSON syntax rules.</p>

            <h3>Tips & Best Practices</h3>
            <ul>
                <li><strong>Always validate before using:</strong> Even if JSON looks correct, run validation to catch
                    hidden syntax errors like trailing commas (not allowed in strict JSON) or single quotes (JSON
                    requires double quotes)</li>
                <li><strong>Use 2-space indentation:</strong> This tool uses 2-space indentation which is the standard
                    for JSON and most JavaScript style guides, providing good readability without excessive whitespace
                </li>
                <li><strong>Minify for production only:</strong> Keep formatted versions for development and
                    documentation. Only minify JSON when you need to reduce file size for production deployment or API
                    responses</li>
                <li><strong>Watch for common errors:</strong> The most frequent JSON errors are trailing commas in
                    objects/arrays, single quotes instead of double quotes, unquoted keys, and undefined values (use
                    null instead)</li>
                <li><strong>Check file size warnings:</strong> Files under 2MB process instantly. Files 2-5MB work but
                    may be slower. Very large JSON files (over 10MB) may cause browser performance issues</li>
                <li><strong>Keep original backups:</strong> When editing important configuration files, always keep a
                    backup of the original before making changes</li>
            </ul>

            <h3>Frequently Asked Questions</h3>

            <p><strong>Q: Is my data safe when using this tool?</strong></p>
            <p>A: Yes, absolutely! All JSON processing happens entirely in your browser using JavaScript. Your data
                never leaves your computer and is never uploaded to any server. We don't store, log, or transmit your
                JSON data in any way. This makes our tool completely safe for sensitive data like API keys,
                configuration files, or proprietary information. You can even use this tool offline after the initial
                page load.</p>

            <p><strong>Q: Do I need to create an account or sign up?</strong></p>
            <p>A: No! All our tools are completely free and don't require any registration, sign-up, or account
                creation. Just visit the page and start using the JSON formatter immediately. There are no limits on
                usage, no premium tiers, and no hidden fees.</p>

            <p><strong>Q: Can I use this tool offline?</strong></p>
            <p>A: Yes! After you load the page for the first time, the tool can work offline because all processing
                happens in your browser. Your browser may cache the page, allowing you to use it without an internet
                connection. This is particularly useful when working in environments with restricted internet access or
                when traveling.</p>

            <p><strong>Q: What are the file size limits?</strong></p>
            <p>A: Files under 2MB work perfectly with instant processing. Files between 2-5MB will work but may take
                slightly longer to process. Files between 5-10MB will show a performance warning but should still work.
                Files over 10MB may cause browser performance issues or slow down significantly, as the entire file must
                be processed in browser memory. For very large JSON files, consider splitting them into smaller chunks
                or using a command-line tool.</p>

            <p><strong>Q: Is this tool really free forever?</strong></p>
            <p>A: Yes! All our tools are 100% free with no hidden costs, premium tiers, or paid features. We may add
                optional ads in the future to support hosting costs, but the core functionality will always remain free.
                We believe developer tools should be accessible to everyone.</p>

            <p><strong>Q: What's the difference between formatting and minifying JSON?</strong></p>
            <p>A: Formatting (also called "beautifying") adds whitespace, newlines, and indentation to make JSON
                human-readable. It's ideal for development, debugging, and documentation. Minifying removes all
                unnecessary whitespace, newlines, and indentation to reduce file size. Minified JSON is harder to read
                but loads faster and uses less bandwidth, making it ideal for production environments, API responses,
                and storage optimization. Both versions contain identical data - only the formatting differs.</p>

            <h3>Understanding JSON Syntax Rules</h3>
            <p>JSON has strict syntax requirements that differ from JavaScript objects. Valid JSON must follow these
                rules:</p>
            <ul>
                <li><strong>Double quotes only:</strong> All strings must use double quotes, not single quotes</li>
                <li><strong>No trailing commas:</strong> The last item in objects and arrays cannot have a trailing
                    comma</li>
                <li><strong>Keys must be quoted:</strong> All object keys must be strings enclosed in double quotes</li>
                <li><strong>Limited data types:</strong> JSON supports only strings, numbers, objects, arrays, booleans
                    (true/false), and null</li>
                <li><strong>No comments:</strong> JSON does not support comments (unlike JavaScript)</li>
                <li><strong>No undefined:</strong> Use null instead of undefined for empty values</li>
            </ul>
            <p>Our validator checks for all these rules and provides clear error messages when violations are detected.
            </p>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 Code Utils. All rights reserved.</p>
        <p>Free developer utilities - 100% client-side processing</p>
    </footer>

    <script src="js/common.js"></script>
    <script>
        // Track this tool visit
        CodeUtils.RecentTools.add({
            id: 'json-formatter',
            name: 'JSON Formatter',
            url: 'json-formatter.html'
        });

        // DOM elements
        const inputJSON = document.getElementById('inputJSON');
        const outputJSON = document.getElementById('outputJSON');
        const fileUpload = document.getElementById('fileUpload');
        const indentSize = document.getElementById('indentSize');

        // Initialize message handler
        CodeUtils.Message.init('message');

        // Initialize drag and drop
        CodeUtils.DragDrop.init('dropZone', async (file) => {
            const sizeCheck = CodeUtils.FileHandler.checkSize(file);
            if (sizeCheck.level === 'error') {
                CodeUtils.Message.error(sizeCheck.message);
                return;
            } else if (sizeCheck.level === 'warning') {
                CodeUtils.Message.warning(sizeCheck.message);
            }

            try {
                const content = await CodeUtils.FileHandler.readAsText(file);
                inputJSON.value = content;
                CodeUtils.Message.success('File loaded successfully!');
            } catch (err) {
                CodeUtils.Message.error('Error reading file');
            }
        });

        // File upload handler
        fileUpload.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const sizeCheck = CodeUtils.FileHandler.checkSize(file);
            if (sizeCheck.level === 'error') {
                CodeUtils.Message.error(sizeCheck.message);
                return;
            } else if (sizeCheck.level === 'warning') {
                CodeUtils.Message.warning(sizeCheck.message);
            }

            try {
                const content = await CodeUtils.FileHandler.readAsText(file);
                inputJSON.value = content;
                CodeUtils.Message.success('File loaded successfully!');
            } catch (err) {
                CodeUtils.Message.error('Error reading file');
            }
        });

        // Get current indent setting
        function getIndent() {
            const val = indentSize.value;
            if (val === 'tab') return '\t';
            return parseInt(val, 10);
        }

        // Save indent preference
        indentSize.addEventListener('change', () => {
            localStorage.setItem('codeutils-json-indent', indentSize.value);
        });

        // Load saved indent preference
        const savedIndent = localStorage.getItem('codeutils-json-indent');
        if (savedIndent) {
            indentSize.value = savedIndent;
        }

        // Parse JSON error to extract line and column info
        function parseJSONError(error, input) {
            const msg = error.message;
            let lineInfo = '';

            // Try to extract position from error message
            // Different browsers format this differently
            const posMatch = msg.match(/position\s+(\d+)/i) ||
                msg.match(/at position\s+(\d+)/i) ||
                msg.match(/column\s+(\d+)/i);

            if (posMatch) {
                const position = parseInt(posMatch[1], 10);
                // Calculate line and column from position
                const lines = input.substring(0, position).split('\n');
                const line = lines.length;
                const column = lines[lines.length - 1].length + 1;
                lineInfo = ` (Line ${line}, Column ${column})`;
            }

            return `Invalid JSON${lineInfo}: ${msg}`;
        }

        // Sort object keys recursively
        function sortObjectKeys(obj) {
            if (Array.isArray(obj)) {
                return obj.map(sortObjectKeys);
            } else if (obj !== null && typeof obj === 'object') {
                const sorted = {};
                Object.keys(obj).sort().forEach(key => {
                    sorted[key] = sortObjectKeys(obj[key]);
                });
                return sorted;
            }
            return obj;
        }

        // Format JSON
        function formatJSON(shouldSort = false) {
            try {
                const input = inputJSON.value.trim();
                if (!input) {
                    CodeUtils.Message.error('Please enter some JSON to format');
                    return;
                }
                let parsed = JSON.parse(input);
                if (shouldSort) {
                    parsed = sortObjectKeys(parsed);
                }
                outputJSON.value = JSON.stringify(parsed, null, getIndent());
                const sortText = shouldSort ? ' and sorted' : '';
                CodeUtils.Message.success(`JSON formatted${sortText} successfully!`);
            } catch (error) {
                CodeUtils.Message.error(parseJSONError(error, inputJSON.value));
                outputJSON.value = '';
            }
        }

        // Sort and format JSON
        function sortAndFormat() {
            formatJSON(true);
        }

        // Minify JSON
        function minifyJSON() {
            try {
                const input = inputJSON.value.trim();
                if (!input) {
                    CodeUtils.Message.error('Please enter some JSON to minify');
                    return;
                }
                const parsed = JSON.parse(input);
                outputJSON.value = JSON.stringify(parsed);
                CodeUtils.Message.success('JSON minified successfully!');
            } catch (error) {
                CodeUtils.Message.error(parseJSONError(error, inputJSON.value));
                outputJSON.value = '';
            }
        }

        // Validate JSON
        function validateJSON() {
            try {
                const input = inputJSON.value.trim();
                if (!input) {
                    CodeUtils.Message.error('Please enter some JSON to validate');
                    return;
                }
                JSON.parse(input);
                CodeUtils.Message.success('Valid JSON!');
            } catch (error) {
                CodeUtils.Message.error(parseJSONError(error, inputJSON.value));
            }
        }

        // Copy output
        async function copyOutput() {
            try {
                await CodeUtils.Clipboard.copy(outputJSON.value);
                CodeUtils.Message.success('Copied to clipboard!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        // Download JSON
        function downloadJSON() {
            if (!outputJSON.value) {
                CodeUtils.Message.error('Nothing to download');
                return;
            }
            CodeUtils.FileHandler.download(outputJSON.value, 'formatted.json', 'application/json');
            CodeUtils.Message.success('File downloaded!');
        }

        // Clear all
        function clearAll() {
            inputJSON.value = '';
            outputJSON.value = '';
            treeView.innerHTML = '';
            searchInput.value = '';
            searchCount.textContent = '';
            currentParsedJSON = null;
            CodeUtils.Message.hide();
        }

        // ===========================================
        // Tree View Implementation
        // ===========================================

        let currentParsedJSON = null;
        let currentViewMode = 'text';
        const treeView = document.getElementById('treeView');
        const searchInput = document.getElementById('searchInput');
        const searchCount = document.getElementById('searchCount');
        const textViewBtn = document.getElementById('textViewBtn');
        const treeViewBtn = document.getElementById('treeViewBtn');

        // Set view mode (text or tree)
        function setViewMode(mode) {
            currentViewMode = mode;

            if (mode === 'text') {
                outputJSON.style.display = 'block';
                treeView.style.display = 'none';
                textViewBtn.classList.add('active');
                treeViewBtn.classList.remove('active');
            } else {
                outputJSON.style.display = 'none';
                treeView.style.display = 'block';
                textViewBtn.classList.remove('active');
                treeViewBtn.classList.add('active');

                // Render tree if we have parsed JSON
                if (currentParsedJSON !== null) {
                    renderTree(currentParsedJSON);
                }
            }
        }

        // Render JSON as a tree
        function renderTree(data) {
            treeView.innerHTML = '';
            const tree = createTreeNode(data, null, false);
            treeView.appendChild(tree);
        }

        // Create a tree node element
        function createTreeNode(value, key, isLast) {
            const container = document.createElement('div');
            container.className = 'tree-node';

            if (value === null) {
                container.innerHTML = formatKeyValue(key, '<span class="tree-value-null">null</span>', isLast);
            } else if (typeof value === 'boolean') {
                container.innerHTML = formatKeyValue(key, `<span class="tree-value-boolean">${value}</span>`, isLast);
            } else if (typeof value === 'number') {
                container.innerHTML = formatKeyValue(key, `<span class="tree-value-number">${value}</span>`, isLast);
            } else if (typeof value === 'string') {
                const escaped = escapeHtml(value);
                container.innerHTML = formatKeyValue(key, `<span class="tree-value-string">"${escaped}"</span>`, isLast);
            } else if (Array.isArray(value)) {
                container.appendChild(createCollapsibleNode(key, value, '[', ']', isLast));
            } else if (typeof value === 'object') {
                container.appendChild(createCollapsibleNode(key, value, '{', '}', isLast));
            }

            return container;
        }

        // Create a collapsible node for objects/arrays
        function createCollapsibleNode(key, value, openBracket, closeBracket, isLast) {
            const wrapper = document.createElement('div');

            const header = document.createElement('div');
            header.className = 'tree-node-header';

            const toggle = document.createElement('span');
            toggle.className = 'tree-toggle';
            toggle.textContent = 'â–¼';

            const isArray = Array.isArray(value);
            const count = isArray ? value.length : Object.keys(value).length;

            let headerHtml = '';
            if (key !== null) {
                headerHtml += `<span class="tree-key">"${escapeHtml(key)}"</span>: `;
            }
            headerHtml += `<span class="tree-bracket">${openBracket}</span>`;
            headerHtml += `<span class="tree-count">${count} ${isArray ? 'items' : 'keys'}</span>`;

            header.appendChild(toggle);
            const content = document.createElement('span');
            content.innerHTML = headerHtml;
            header.appendChild(content);

            const children = document.createElement('div');
            children.className = 'tree-children';

            if (isArray) {
                value.forEach((item, index) => {
                    children.appendChild(createTreeNode(item, null, index === value.length - 1));
                });
            } else {
                const keys = Object.keys(value);
                keys.forEach((k, index) => {
                    children.appendChild(createTreeNode(value[k], k, index === keys.length - 1));
                });
            }

            const closer = document.createElement('div');
            closer.innerHTML = `<span class="tree-bracket">${closeBracket}</span>${isLast ? '' : '<span class="tree-comma">,</span>'}`;

            header.addEventListener('click', () => {
                toggle.classList.toggle('collapsed');
                children.classList.toggle('collapsed');
            });

            wrapper.appendChild(header);
            wrapper.appendChild(children);
            wrapper.appendChild(closer);

            return wrapper;
        }

        // Format key-value pair
        function formatKeyValue(key, valueHtml, isLast) {
            let html = '';
            if (key !== null) {
                html += `<span class="tree-key">"${escapeHtml(key)}"</span>: `;
            }
            html += valueHtml;
            if (!isLast) {
                html += '<span class="tree-comma">,</span>';
            }
            return html;
        }

        // Escape HTML special characters
        function escapeHtml(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        // ===========================================
        // Search Implementation
        // ===========================================

        let searchMatches = [];
        let currentMatchIndex = -1;

        searchInput.addEventListener('input', CodeUtils.Utils.debounce(() => {
            performSearch();
        }, 200));

        searchInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (e.shiftKey) {
                    navigateSearch(-1);
                } else {
                    navigateSearch(1);
                }
            }
        });

        function performSearch() {
            const query = searchInput.value.trim().toLowerCase();
            searchMatches = [];
            currentMatchIndex = -1;

            if (!query) {
                searchCount.textContent = '';
                // Remove highlights
                if (currentViewMode === 'tree') {
                    renderTree(currentParsedJSON);
                }
                return;
            }

            const text = outputJSON.value;
            if (!text) {
                searchCount.textContent = '';
                return;
            }

            // Find all matches
            let pos = 0;
            const lowerText = text.toLowerCase();
            while ((pos = lowerText.indexOf(query, pos)) !== -1) {
                searchMatches.push(pos);
                pos += query.length;
            }

            if (searchMatches.length > 0) {
                currentMatchIndex = 0;
                searchCount.textContent = `1/${searchMatches.length}`;
                highlightCurrentMatch();
            } else {
                searchCount.textContent = '0 found';
            }
        }

        function navigateSearch(direction) {
            if (searchMatches.length === 0) return;

            currentMatchIndex += direction;
            if (currentMatchIndex >= searchMatches.length) {
                currentMatchIndex = 0;
            } else if (currentMatchIndex < 0) {
                currentMatchIndex = searchMatches.length - 1;
            }

            searchCount.textContent = `${currentMatchIndex + 1}/${searchMatches.length}`;
            highlightCurrentMatch();
        }

        function highlightCurrentMatch() {
            if (currentViewMode === 'text' && searchMatches.length > 0) {
                const pos = searchMatches[currentMatchIndex];
                const query = searchInput.value.trim();

                // Select and scroll to the match in textarea
                outputJSON.focus();
                outputJSON.setSelectionRange(pos, pos + query.length);

                // Scroll to selection (approximate)
                const lineHeight = 21; // approximate line height
                const charsPerLine = 80; // approximate
                const lineNumber = Math.floor(pos / charsPerLine);
                outputJSON.scrollTop = lineNumber * lineHeight - 100;
            }
        }

        // ===========================================
        // Update formatJSON to support tree view
        // ===========================================

        // Override format function to also update tree
        const originalFormatJSON = formatJSON;
        formatJSON = function (shouldSort = false) {
            try {
                const input = inputJSON.value.trim();
                if (!input) {
                    CodeUtils.Message.error('Please enter some JSON to format');
                    return;
                }
                let parsed = JSON.parse(input);
                if (shouldSort) {
                    parsed = sortObjectKeys(parsed);
                }
                currentParsedJSON = parsed;
                outputJSON.value = JSON.stringify(parsed, null, getIndent());

                // Update tree view if visible
                if (currentViewMode === 'tree') {
                    renderTree(parsed);
                }

                const sortText = shouldSort ? ' and sorted' : '';
                CodeUtils.Message.success(`JSON formatted${sortText} successfully!`);
            } catch (error) {
                CodeUtils.Message.error(parseJSONError(error, inputJSON.value));
                outputJSON.value = '';
                treeView.innerHTML = '';
                currentParsedJSON = null;
            }
        };

        // Keyboard shortcuts
        CodeUtils.Shortcuts.register('Enter', formatJSON, true);
        CodeUtils.Shortcuts.register('m', minifyJSON, true);
        CodeUtils.Shortcuts.register('k', copyOutput, true);
        CodeUtils.Shortcuts.register('s', sortAndFormat, true);

        // ===========================================
        // Phase 3: JSON Repair
        // ===========================================

        function repairJSON() {
            let input = inputJSON.value.trim();
            if (!input) {
                CodeUtils.Message.error('Please enter some JSON to repair');
                return;
            }

            let repaired = input;
            let fixes = [];

            // Remove JavaScript comments (// and /* */)
            const beforeComments = repaired;
            repaired = repaired.replace(/\/\/[^\n]*/g, '');
            repaired = repaired.replace(/\/\*[\s\S]*?\*\//g, '');
            if (repaired !== beforeComments) fixes.push('removed comments');

            // Replace single quotes with double quotes
            const beforeQuotes = repaired;
            repaired = repaired.replace(/'/g, '"');
            if (repaired !== beforeQuotes) fixes.push('fixed single quotes');

            // Fix unquoted keys (simple pattern)
            const beforeKeys = repaired;
            repaired = repaired.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
            if (repaired !== beforeKeys) fixes.push('quoted unquoted keys');

            // Remove trailing commas before } or ]
            const beforeTrailing = repaired;
            repaired = repaired.replace(/,(\s*[}\]])/g, '$1');
            if (repaired !== beforeTrailing) fixes.push('removed trailing commas');

            // Replace undefined with null
            const beforeUndefined = repaired;
            repaired = repaired.replace(/:\s*undefined\b/g, ': null');
            if (repaired !== beforeUndefined) fixes.push('replaced undefined with null');

            // Try to parse the repaired JSON
            try {
                const parsed = JSON.parse(repaired);
                inputJSON.value = repaired;
                currentParsedJSON = parsed;
                outputJSON.value = JSON.stringify(parsed, null, getIndent());

                if (currentViewMode === 'tree') {
                    renderTree(parsed);
                }

                if (fixes.length > 0) {
                    CodeUtils.Message.success(`Repaired: ${fixes.join(', ')}`);
                } else {
                    CodeUtils.Message.success('JSON was already valid!');
                }
            } catch (error) {
                CodeUtils.Message.error(`Could not repair: ${error.message}`);
            }
        }

        // ===========================================
        // Phase 3: Load from URL
        // ===========================================

        const urlInput = document.getElementById('urlInput');

        async function loadFromURL() {
            const url = urlInput.value.trim();
            if (!url) {
                CodeUtils.Message.error('Please enter a URL');
                return;
            }

            // Basic URL validation
            try {
                new URL(url);
            } catch {
                CodeUtils.Message.error('Invalid URL format');
                return;
            }

            CodeUtils.Message.info('Loading JSON from URL...');

            try {
                // Try direct fetch first (works for CORS-enabled APIs)
                const response = await fetch(url, {
                    headers: { 'Accept': 'application/json' }
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const contentType = response.headers.get('content-type');
                if (contentType && !contentType.includes('json') && !contentType.includes('text')) {
                    CodeUtils.Message.warning('Response may not be JSON, attempting to parse anyway...');
                }

                const text = await response.text();

                // Validate it's valid JSON
                const parsed = JSON.parse(text);

                inputJSON.value = JSON.stringify(parsed, null, getIndent());
                currentParsedJSON = parsed;
                outputJSON.value = JSON.stringify(parsed, null, getIndent());

                if (currentViewMode === 'tree') {
                    renderTree(parsed);
                }

                CodeUtils.Message.success('JSON loaded from URL!');
            } catch (error) {
                if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    CodeUtils.Message.error('CORS error: Cannot load from this URL. Try a CORS-enabled API or use a browser extension.');
                } else {
                    CodeUtils.Message.error(`Error: ${error.message}`);
                }
            }
        }

        // Enter key to trigger load
        urlInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                loadFromURL();
            }
        });

        // ===========================================
        // Phase 3: JSONPath Query (from jsonpath-tester)
        // ===========================================

        const jsonPathInput = document.getElementById('jsonPathInput');

        // JSONPath implementation (reused from jsonpath-tester.html)
        function jsonPath(obj, path) {
            if (path === '$') return [obj];

            const results = [];
            const segments = [];
            let current = '';
            let inBracket = false;

            // Parse path into segments
            for (let i = 1; i < path.length; i++) {
                const char = path[i];
                if (char === '[') {
                    if (current) segments.push({ type: 'key', value: current });
                    current = '';
                    inBracket = true;
                } else if (char === ']') {
                    segments.push({ type: 'bracket', value: current });
                    current = '';
                    inBracket = false;
                } else if (char === '.' && !inBracket) {
                    if (current) segments.push({ type: 'key', value: current });
                    current = '';
                    if (path[i + 1] === '.') {
                        segments.push({ type: 'recursive' });
                        i++;
                    }
                } else {
                    current += char;
                }
            }
            if (current) segments.push({ type: 'key', value: current });

            function traverse(data, segIndex, collector) {
                if (segIndex >= segments.length) {
                    collector.push(data);
                    return;
                }

                const seg = segments[segIndex];

                if (seg.type === 'key') {
                    if (data && typeof data === 'object' && seg.value in data) {
                        traverse(data[seg.value], segIndex + 1, collector);
                    }
                } else if (seg.type === 'bracket') {
                    if (seg.value === '*') {
                        if (Array.isArray(data)) {
                            data.forEach(item => traverse(item, segIndex + 1, collector));
                        } else if (data && typeof data === 'object') {
                            Object.values(data).forEach(item => traverse(item, segIndex + 1, collector));
                        }
                    } else if (seg.value.startsWith('?')) {
                        // Filter expression
                        const expr = seg.value.slice(2, -1);
                        if (Array.isArray(data)) {
                            data.forEach(item => {
                                try {
                                    const fn = new Function('@', `return ${expr.replace(/@/g, '@')}`);
                                    if (fn(item)) traverse(item, segIndex + 1, collector);
                                } catch { }
                            });
                        }
                    } else {
                        const idx = parseInt(seg.value);
                        if (Array.isArray(data) && data[idx] !== undefined) {
                            traverse(data[idx], segIndex + 1, collector);
                        }
                    }
                } else if (seg.type === 'recursive') {
                    const nextSeg = segments[segIndex + 1];
                    function recurse(d) {
                        if (nextSeg && nextSeg.type === 'key' && d && typeof d === 'object') {
                            if (nextSeg.value in d) {
                                traverse(d[nextSeg.value], segIndex + 2, collector);
                            }
                            Object.values(d).forEach(v => {
                                if (v && typeof v === 'object') recurse(v);
                            });
                        }
                    }
                    recurse(data);
                }
            }

            traverse(obj, 0, results);
            return results;
        }

        function queryJSONPath() {
            const path = jsonPathInput.value.trim();
            if (!path) {
                CodeUtils.Message.error('Please enter a JSONPath expression');
                return;
            }

            if (!path.startsWith('$')) {
                CodeUtils.Message.error('JSONPath must start with $');
                return;
            }

            const input = inputJSON.value.trim();
            if (!input) {
                CodeUtils.Message.error('Please enter some JSON first');
                return;
            }

            try {
                const data = JSON.parse(input);
                const results = jsonPath(data, path);

                if (results.length === 0) {
                    CodeUtils.Message.warning('No matches found');
                    outputJSON.value = '[]';
                } else {
                    outputJSON.value = JSON.stringify(
                        results.length === 1 ? results[0] : results,
                        null,
                        getIndent()
                    );
                    currentParsedJSON = results.length === 1 ? results[0] : results;

                    if (currentViewMode === 'tree') {
                        renderTree(currentParsedJSON);
                    }

                    CodeUtils.Message.success(`Found ${results.length} match(es)`);
                }
            } catch (error) {
                CodeUtils.Message.error(`Error: ${error.message}`);
            }
        }

        // Enter key to trigger query
        jsonPathInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                queryJSONPath();
            }
        });

        // ===========================================
        // Phase 3: JSON Diff/Compare Mode
        // ===========================================

        let diffMode = false;
        const diffModeBtn = document.getElementById('diffModeBtn');
        const editorContainer = document.querySelector('.editor-container');
        let secondInput = null;

        function toggleDiffMode() {
            diffMode = !diffMode;

            if (diffMode) {
                // Enter diff mode
                diffModeBtn.classList.add('active');
                diffModeBtn.textContent = 'Exit Compare';

                // Create second input area
                const firstEditor = editorContainer.querySelector('.editor-section');
                secondInput = document.createElement('div');
                secondInput.className = 'editor-section';
                secondInput.id = 'secondEditorSection';
                secondInput.innerHTML = `
                    <div class="editor-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <span>Second JSON</span>
                        <button class="btn" onclick="compareJSON()" style="padding: 6px 14px; font-size: 13px;">Compare Now</button>
                    </div>
                    <textarea id="inputJSON2" class="editor" placeholder="Paste second JSON here..."></textarea>
                `;
                firstEditor.after(secondInput);

                // Update first input label
                firstEditor.querySelector('.editor-header').textContent = 'First JSON';

                // Resize editors
                editorContainer.style.gridTemplateColumns = '1fr 1fr 1fr';

                // Add Ctrl+Enter shortcut for second input
                setTimeout(() => {
                    const input2 = document.getElementById('inputJSON2');
                    if (input2) {
                        input2.addEventListener('keydown', (e) => {
                            if (e.ctrlKey && e.key === 'Enter') {
                                e.preventDefault();
                                compareJSON();
                            }
                        });
                    }
                }, 50);

                CodeUtils.Message.info('Paste JSON in both panels, then click "Compare Now" or press Ctrl+Enter');

            } else {
                // Exit diff mode
                diffModeBtn.classList.remove('active');
                diffModeBtn.textContent = 'Compare';

                // Remove second input
                if (secondInput) {
                    secondInput.remove();
                    secondInput = null;
                }

                // Restore first input label
                editorContainer.querySelector('.editor-section .editor-header').textContent = 'Input JSON';

                // Restore grid
                editorContainer.style.gridTemplateColumns = '1fr 1fr';
            }
        }

        // Compare function
        function compareJSON() {
            if (!diffMode) {
                CodeUtils.Message.error('Enter Compare mode first');
                return;
            }

            const json1 = inputJSON.value.trim();
            const json2 = document.getElementById('inputJSON2')?.value.trim();

            if (!json1 || !json2) {
                CodeUtils.Message.error('Please enter JSON in both inputs');
                return;
            }

            try {
                const obj1 = JSON.parse(json1);
                const obj2 = JSON.parse(json2);

                const diff = findDifferences(obj1, obj2, '');

                if (diff.length === 0) {
                    outputJSON.value = 'âœ“ Both JSON documents are identical!';
                    CodeUtils.Message.success('No differences found!');
                } else {
                    outputJSON.value = '=== Differences Found ===\n\n' +
                        diff.map(d => `${d.path}:\n  Left:  ${JSON.stringify(d.left)}\n  Right: ${JSON.stringify(d.right)}`).join('\n\n');
                    CodeUtils.Message.info(`Found ${diff.length} difference(s)`);
                }
            } catch (error) {
                CodeUtils.Message.error(`Error: ${error.message}`);
            }
        }

        function findDifferences(obj1, obj2, path) {
            const diffs = [];

            // Handle null/undefined
            if (obj1 === null || obj2 === null || typeof obj1 !== 'object' || typeof obj2 !== 'object') {
                if (obj1 !== obj2) {
                    diffs.push({ path: path || '$', left: obj1, right: obj2 });
                }
                return diffs;
            }

            // Handle arrays
            if (Array.isArray(obj1) && Array.isArray(obj2)) {
                const maxLen = Math.max(obj1.length, obj2.length);
                for (let i = 0; i < maxLen; i++) {
                    const itemPath = `${path}[${i}]`;
                    if (i >= obj1.length) {
                        diffs.push({ path: itemPath, left: undefined, right: obj2[i] });
                    } else if (i >= obj2.length) {
                        diffs.push({ path: itemPath, left: obj1[i], right: undefined });
                    } else {
                        diffs.push(...findDifferences(obj1[i], obj2[i], itemPath));
                    }
                }
                return diffs;
            }

            // Handle objects
            const allKeys = new Set([...Object.keys(obj1), ...Object.keys(obj2)]);
            for (const key of allKeys) {
                const keyPath = path ? `${path}.${key}` : `$.${key}`;
                if (!(key in obj1)) {
                    diffs.push({ path: keyPath, left: undefined, right: obj2[key] });
                } else if (!(key in obj2)) {
                    diffs.push({ path: keyPath, left: obj1[key], right: undefined });
                } else {
                    diffs.push(...findDifferences(obj1[key], obj2[key], keyPath));
                }
            }

            return diffs;
        }

        // Update format button to also compare in diff mode
        const originalFormatForDiff = formatJSON;
        formatJSON = function (shouldSort = false) {
            if (diffMode) {
                compareJSON();
            } else {
                originalFormatForDiff(shouldSort);
            }
        };
    </script>
</body>

</html>