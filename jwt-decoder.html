<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT Decoder with Signature Verification | Decode & Verify JWTs Online - Code Utils</title>
    <meta name="description" content="Decode and verify JSON Web Tokens (JWT) with HS256 signature verification. Visual expiration status, token history with labels, claim tooltips, and auto-decode. 100% private - tokens never leave your browser. Try it!">
    <meta name="keywords" content="jwt decoder, jwt verifier, jwt signature verification, jwt parser, json web token, jwt debugger, decode jwt, jwt inspector, jwt online, hs256">
    <link rel="canonical" href="https://codeutils.org/jwt-decoder">

    <!-- Favicon and Touch Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#3498db">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://codeutils.org/jwt-decoder">
    <meta property="og:title" content="JWT Decoder with Signature Verification - Code Utils">
    <meta property="og:description" content="Decode and verify JWTs with HS256 signature verification, visual expiration badges, token history, and claim tooltips. 100% private client-side processing.">
    <meta property="og:image" content="https://codeutils.org/images/og/jwt-decoder.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="JWT Decoder with Signature Verification - Free online tool">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="JWT Decoder with Signature Verification - Code Utils">
    <meta name="twitter:description" content="Decode & verify JWTs with HS256 verification, token history, and visual expiration status. Free tool with 100% private processing.">
    <meta name="twitter:image" content="https://codeutils.org/images/og/jwt-decoder.png">

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RPHPBJ4291"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-RPHPBJ4291');
    </script>

    <!-- Structured Data: WebApplication Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "JWT Decoder - Code Utils",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Free JWT decoder with HS256 signature verification. Decode and verify JSON Web Tokens, save token history with labels, view visual expiration status, and get claim explanations. 100% client-side processing.",
      "url": "https://codeutils.org/jwt-decoder",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.6",
        "ratingCount": "1180"
      }
    }
    </script>

    <!-- Structured Data: FAQ Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Does this tool verify JWT signatures?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! This tool now supports HS256 signature verification. You can verify JWT signatures signed with HMAC-SHA256 by entering your secret key in the Verify Signature section. The tool will validate whether the signature is authentic and the token hasn't been tampered with. Important: Only use test or development keys‚Äînever enter production secret keys in browser tools. For production tokens, always verify signatures on your secure server. Note: This tool currently supports HS256 only; RS256 and ES256 support may be added in future updates."
          }
        },
        {
          "@type": "Question",
          "name": "How do I check if a JWT is expired?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "JWTs contain an 'exp' claim that specifies the expiration time as a Unix timestamp (seconds since epoch). This tool automatically checks the expiration time and displays whether the token is valid or expired. Simply decode the JWT using this tool and look for the expiration status in the payload output. If the current time is greater than the exp value, the token is expired. Your server must also validate expiration before accepting the token."
          }
        },
        {
          "@type": "Question",
          "name": "What are JWT claims and which ones matter?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "JWT claims are pieces of information stored in the payload (the middle part of a JWT). Standard claims include: sub (subject/user ID), iss (issuer), aud (audience), exp (expiration time), iat (issued at time), nbf (not before time), and jti (unique identifier). Custom claims specific to your application can also be included. When debugging tokens, check the 'exp' and 'sub' claims first to verify the token isn't expired and belongs to the correct user."
          }
        },
        {
          "@type": "Question",
          "name": "Can I modify or create a JWT with this tool?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "No, this tool only decodes JWTs. You cannot modify or create new tokens here. To create or modify JWTs, use backend code or specialized JWT tools that handle signing. Any JWT created without the proper signature will be rejected by your server. If you decode a JWT and want to see how changes would affect it, modify the payload values conceptually and re-encode manually, but understand this wouldn't be a valid token without proper signing."
          }
        },
        {
          "@type": "Question",
          "name": "When and why should I use JWTs for authentication?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "JWTs are ideal for stateless authentication in modern web and mobile applications, APIs, and microservices. They contain all user information in the token itself, eliminating the need for server-side session storage. JWTs are URL-safe, can be easily transmitted in headers, and work well with CORS and cross-domain requests. However, JWTs require HTTPS to prevent interception, proper signature verification on the server, and careful management of sensitive information in the payload (don't include passwords or secrets)."
          }
        },
        {
          "@type": "Question",
          "name": "What are the three parts of a JWT and what do they mean?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "A JWT has three parts separated by dots: Header (specifies token type and signing algorithm), Payload (contains the actual data/claims including user info and expiration), and Signature (cryptographically proves the token hasn't been tampered with). The header and payload are Base64-encoded and human-readable. The signature can only be verified with the secret key. This tool decodes and displays all three parts so you can inspect the data and signature value."
          }
        },
        {
          "@type": "Question",
          "name": "What is the token history feature and how does it help?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Token history is a unique feature that lets you save up to 10 JWT tokens with custom labels for quick access during debugging. For example, you can save tokens labeled 'Production API', 'Staging Server', 'Test User 1', etc. This eliminates the need to constantly re-paste tokens when switching between different environments or test accounts. Simply select a saved token from the dropdown to instantly load and decode it. This feature is stored locally in your browser and never sent to any server, maintaining complete privacy."
          }
        }
      ]
    }
    </script>

    <link rel="stylesheet" href="css/common.css">
    <style>
        .jwt-section {
            margin-bottom: var(--spacing-md);
        }
        .jwt-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: var(--radius) var(--radius) 0 0;
            font-weight: 600;
        }
        .jwt-section-header.header-section { color: #e74c3c; }
        .jwt-section-header.payload-section { color: #9b59b6; }
        .jwt-section-header.signature-section { color: #3498db; }
        .jwt-section-content {
            padding: var(--spacing-md);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0 0 var(--radius) var(--radius);
            font-family: var(--font-mono);
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 80px;
        }
        .claim-row {
            display: flex;
            padding: var(--spacing-xs) 0;
            border-bottom: 1px solid var(--border);
        }
        .claim-row:last-child {
            border-bottom: none;
        }
        .claim-name {
            font-weight: 600;
            min-width: 120px;
            color: var(--primary);
        }
        .claim-value {
            flex: 1;
            word-break: break-all;
        }
        .claim-description {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-left: var(--spacing-xs);
        }
        .expiry-warning {
            color: #e74c3c;
            font-weight: 600;
        }
        .expiry-valid {
            color: #27ae60;
            font-weight: 600;
        }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: var(--spacing-xs);
        }
        .badge-valid {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .badge-expired {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .badge-expiring {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        [data-theme="dark"] .badge-valid {
            background: #1e4620;
            color: #a3e9a4;
            border: 1px solid #2d5930;
        }
        [data-theme="dark"] .badge-expired {
            background: #4a1a1a;
            color: #f5b7b1;
            border: 1px solid #5e2424;
        }
        [data-theme="dark"] .badge-expiring {
            background: #4a3a0a;
            color: #f9e79f;
            border: 1px solid #5e4b10;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            margin-left: 4px;
            color: var(--primary);
            font-size: 0.75rem;
            width: 14px;
            height: 14px;
            text-align: center;
            border: 1px solid var(--primary);
            border-radius: 50%;
            line-height: 12px;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: var(--bg-secondary);
            color: var(--text);
            text-align: left;
            border-radius: var(--radius);
            padding: var(--spacing-sm);
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--border);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 0.875rem;
            line-height: 1.4;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .token-history {
            margin-bottom: var(--spacing-md);
        }
        .token-history-controls {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            flex-wrap: wrap;
        }
        .token-history-select {
            flex: 1;
            min-width: 200px;
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text);
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }
        .save-token-form {
            display: flex;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-xs);
            align-items: center;
        }
        .save-token-input {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text);
            font-size: 0.875rem;
        }
        .verify-section {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }
        .verify-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            user-select: none;
        }
        .verify-content {
            margin-top: var(--spacing-md);
        }
        .verify-result {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius);
            font-weight: 600;
        }
        .verify-result.valid {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .verify-result.invalid {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        [data-theme="dark"] .verify-result.valid {
            background: #1e4620;
            color: #a3e9a4;
            border: 1px solid #2d5930;
        }
        [data-theme="dark"] .verify-result.invalid {
            background: #4a1a1a;
            color: #f5b7b1;
            border: 1px solid #5e2424;
        }
        .collapse-icon {
            transition: transform 0.3s;
        }
        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="header-logo">
                <h1>Code Utils</h1>
            </a>
            <nav class="header-nav">
                <a href="index.html" class="btn btn-outline btn-sm">All Tools</a>
                <button class="theme-toggle" onclick="CodeUtils.Theme.toggle()">Toggle Dark Mode</button>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="card" style="margin-bottom: var(--spacing-md); padding: var(--spacing-md);">
            <h2 style="margin-bottom: var(--spacing-xs); color: var(--primary);">JWT Decoder</h2>
            <p style="margin: 0; color: var(--text-secondary);">Instantly decode and verify JSON Web Tokens (JWTs) with HS256 signature verification, visual expiration badges, and token history management. JWTs are used extensively in modern authentication systems, APIs, microservices, and single-page applications (SPAs) for secure, stateless authentication. This tool helps you quickly debug authentication issues, verify token authenticity, check expiration times with color-coded badges, and inspect claims with helpful tooltips. Unique token history feature lets you save up to 10 tokens with custom labels for faster debugging. Simply paste your JWT token and it auto-decodes instantly with visual status indicators. Verify signatures using your HS256 secret key to ensure tokens haven't been tampered with. All processing happens completely securely in your browser‚Äîtokens never leave your computer or touch our servers. Perfect for developers, DevOps engineers, and security professionals debugging JWT-based authentication systems.</p>
        </div>

        <div class="controls">
            <div class="controls-group">
                <button class="btn" onclick="decodeJWT()" title="Decode JWT (Ctrl+Enter)">Decode</button>
            </div>
            <div class="controls-group">
                <button class="btn btn-secondary" onclick="copyDecoded()" title="Copy Decoded (Ctrl+K)">Copy Decoded</button>
                <button class="btn btn-secondary" onclick="loadSample()">Load Sample</button>
            </div>
            <button class="btn btn-outline" onclick="clearAll()">Clear</button>
        </div>

        <!-- Token History -->
        <div class="token-history">
            <div class="token-history-controls">
                <select id="tokenHistorySelect" class="token-history-select" onchange="loadFromHistory()">
                    <option value="">üìö Token History (0 saved)</option>
                </select>
                <button class="btn btn-sm btn-outline" onclick="toggleSaveForm()">Save Token</button>
                <button class="btn btn-sm btn-outline" onclick="clearHistory()">Clear History</button>
            </div>
            <div id="saveTokenForm" class="save-token-form" style="display: none;">
                <input type="text" id="tokenLabel" class="save-token-input" placeholder="Enter label (e.g., 'Production', 'Test User 1')" maxlength="50">
                <button class="btn btn-sm" onclick="saveToken()">Save</button>
                <button class="btn btn-sm btn-outline" onclick="toggleSaveForm()">Cancel</button>
            </div>
        </div>

        <div id="message" class="message"></div>

        <div class="editor-section" style="margin-bottom: var(--spacing-md);">
            <div class="editor-header">JWT Token</div>
            <textarea id="inputJWT" class="editor" placeholder="Paste your JWT token here..." style="min-height: 100px;"></textarea>
        </div>

        <!-- Signature Verification -->
        <div class="verify-section">
            <div class="verify-header" onclick="toggleVerifySection()">
                <div>
                    <strong>üîê Verify Signature (Optional)</strong>
                    <span style="font-size: 0.875rem; color: var(--text-secondary); margin-left: var(--spacing-sm);">HS256 algorithm only</span>
                </div>
                <span class="collapse-icon" id="verifyCollapseIcon">‚ñº</span>
            </div>
            <div id="verifyContent" class="verify-content" style="display: none;">
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-sm);">
                    ‚ö†Ô∏è <strong>Security Warning:</strong> Enter your secret key only for testing. Never use production keys in browser tools.
                </p>
                <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Secret Key</label>
                <input type="text" id="secretKey" class="editor" placeholder="Enter your HS256 secret key..." style="margin-bottom: var(--spacing-sm);">
                <button class="btn" onclick="verifySignature()">Verify Signature</button>
                <div id="verifyResult"></div>
            </div>
        </div>

        <div id="decodedOutput">
            <div class="jwt-section">
                <div class="jwt-section-header header-section">
                    <span>Header</span>
                    <button class="btn btn-sm btn-outline" onclick="copySection('header')">Copy</button>
                </div>
                <div class="jwt-section-content" id="headerOutput">Decoded header will appear here...</div>
            </div>

            <div class="jwt-section">
                <div class="jwt-section-header payload-section">
                    <span>Payload</span>
                    <button class="btn btn-sm btn-outline" onclick="copySection('payload')">Copy</button>
                </div>
                <div class="jwt-section-content" id="payloadOutput">Decoded payload will appear here...</div>
            </div>

            <div class="jwt-section">
                <div class="jwt-section-header signature-section">
                    <span>Signature</span>
                    <button class="btn btn-sm btn-outline" onclick="copySection('signature')">Copy</button>
                </div>
                <div class="jwt-section-content" id="signatureOutput">Signature will appear here...</div>
            </div>
        </div>

        <!-- Related Tools -->
        <div class="related-tools">
            <h3>Related Tools</h3>
            <ul class="related-tools-list">
                <li><a href="base64-encoder.html">Base64 Encoder/Decoder</a></li>
                <li><a href="json-formatter.html">JSON Formatter</a></li>
                <li><a href="hash-generator.html">Hash Generator</a></li>
                <li><a href="timestamp-converter.html">Timestamp Converter</a></li>
            </ul>
        </div>

        <!-- Info Section -->
        <div class="info-section">
            <h2>About JWT Decoder</h2>
            <p>JSON Web Tokens (JWTs) are a standard for securely transmitting information as JSON objects in authentication systems, APIs, and microservices architectures. This tool provides a fast, secure way to decode and inspect JWTs by extracting and displaying the header, payload, and signature information. JWTs are stateless, URL-safe, and work seamlessly across domains, making them ideal for modern web applications, mobile apps, and APIs. Whether you're debugging authentication issues, verifying user claims, checking token expiration, or understanding API authentication flows, this decoder simplifies JWT inspection with an instant, privacy-first approach.</p>

            <h3>Key Features</h3>
            <ul>
                <li><strong>Decode All JWT Parts:</strong> Instantly extract and display header, payload, and signature from any JWT token</li>
                <li><strong>Visual Expiration Status:</strong> Color-coded badges show at a glance if token is valid (green), expired (red), or expiring soon (yellow) with time remaining</li>
                <li><strong>HS256 Signature Verification:</strong> Verify JWT signatures using HMAC-SHA256 algorithm with your secret key to ensure token authenticity</li>
                <li><strong>Token History with Labels:</strong> Save up to 10 tokens with custom labels (e.g., "Production", "Test User 1") for quick access during debugging‚Äîunique feature not found in other tools!</li>
                <li><strong>Claim Tooltips:</strong> Hover over standard claims to see explanations of what each claim means (sub, iss, aud, exp, etc.)</li>
                <li><strong>Auto-Decode on Input:</strong> Automatically decodes JWTs as you type or paste‚Äîno need to click the Decode button</li>
                <li><strong>Timestamp Conversion:</strong> Automatically converts Unix timestamps (iat, exp, nbf) to human-readable dates</li>
                <li><strong>One-Click Copy:</strong> Copy individual sections (header, payload, signature) or all decoded data to clipboard</li>
                <li><strong>Sample JWT:</strong> Load a sample token to learn JWT structure without needing your own token</li>
                <li><strong>100% Client-Side:</strong> All decoding and verification happens in your browser‚Äîtokens never leave your computer</li>
            </ul>

            <h3>How to Use This Tool</h3>

            <p><strong>Method 1: Decode Your JWT</strong></p>
            <ol>
                <li>Copy your JWT token from your authentication system, API response, or browser storage</li>
                <li>Paste it into the "JWT Token" text area</li>
                <li>Click the "Decode" button (or press Ctrl+Enter) to instantly decode</li>
                <li>View the decoded header, payload, and signature in the output sections below</li>
                <li>Check the expiration status‚Äîautomatically shown if the token has an exp claim</li>
            </ol>

            <p><strong>Method 2: Inspect Individual Token Parts</strong></p>
            <ol>
                <li>After decoding, each section (Header, Payload, Signature) displays separately for easy inspection</li>
                <li>Click the "Copy" button on any section to copy just that part</li>
                <li>Use the "Copy Decoded" button to copy all three parts together as formatted text</li>
            </ol>

            <p><strong>Method 3: Save and Manage Token History</strong></p>
            <ol>
                <li>After decoding a token, click "Save Token" button</li>
                <li>Enter a descriptive label (e.g., "Production API", "Test User 1", "Staging Token")</li>
                <li>Access saved tokens anytime from the "Token History" dropdown</li>
                <li>Keep up to 10 frequently-used tokens for quick debugging</li>
            </ol>

            <p><strong>Method 4: Verify Token Signature (HS256)</strong></p>
            <ol>
                <li>Decode your JWT token first</li>
                <li>Click "Verify Signature" section to expand</li>
                <li>Enter your HS256 secret key (‚ö†Ô∏è test keys only, never production keys!)</li>
                <li>Click "Verify Signature" to check if the token is authentic</li>
                <li>Green checkmark means valid, red X means tampered or wrong key</li>
            </ol>

            <p><strong>Method 5: Learn with Sample Token</strong></p>
            <ol>
                <li>Click the "Load Sample" button to pre-load an example JWT</li>
                <li>The token auto-decodes to show JWT structure</li>
                <li>Examine the header, payload, and claims to understand JWT format</li>
                <li>Hover over claims to see explanations with tooltips</li>
            </ol>

            <p><strong>Keyboard Shortcuts (Power Users)</strong></p>
            <ul>
                <li><strong>Ctrl + Enter</strong> - Decode JWT token</li>
                <li><strong>Ctrl + K</strong> - Copy all decoded output</li>
                <li><strong>Type or Paste</strong> - Auto-decode as you type (500ms delay)</li>
            </ul>

            <p><em>Pro tip: This tool auto-decodes as you type or paste, so you can instantly see token contents without clicking any buttons. Save frequently-used tokens with custom labels for even faster debugging!</em></p>

            <h3>Common Use Cases</h3>

            <p><strong>Debugging Authentication and Authorization Issues</strong></p>
            <p>When users report authentication problems or receive "unauthorized" errors, extract their JWT and decode it using this tool to verify the token contents, check expiration status, and confirm claims (sub for user ID, roles for authorization). Often you'll discover tokens are expired, missing required claims, or contain incorrect values‚Äîinformation that's impossible to see without decoding. This tool instantly reveals the underlying issue without needing server logs.</p>

            <p><strong>Verifying User Claims in SPA Applications</strong></p>
            <p>Single-page applications (SPAs) that store JWTs in localStorage or sessionStorage often need to inspect what user data is stored in the token. Decode the JWT to verify the user ID, email, roles, permissions, and other claims are correctly set. This is essential when debugging authorization issues where a user claims they should have certain permissions but the token doesn't contain the expected claims.</p>

            <p><strong>Inspecting API Response Tokens</strong></p>
            <p>When testing APIs that return JWTs in responses (especially OAuth2 or OpenID Connect flows), paste the returned token here to instantly see what the API included in the token. Verify that all expected claims are present, user information is correct, and the token hasn't expired. This speeds up API development and testing significantly compared to manually decoding tokens on the server.</p>

            <p><strong>Understanding JWT Structure for Development and Learning</strong></p>
            <p>New developers learning about JWT authentication can use this tool to understand the three-part structure (Header.Payload.Signature), see real token examples, and learn what information JWTs typically contain. The sample token feature provides a hands-on way to explore JWTs without requiring access to a live authentication system.</p>

            <h3>Tips & Best Practices</h3>
            <ul>
                <li><strong>Always verify on the server:</strong> This tool only decodes‚Äîit doesn't verify signatures. Never make security decisions based solely on decoded content. Always verify JWT signatures on your backend</li>
                <li><strong>Check expiration first:</strong> When debugging authentication, the expiration (exp) claim is often the culprit. This tool automatically shows expiration status</li>
                <li><strong>Inspect the aud claim:</strong> If your JWT has an 'aud' (audience) claim, verify it matches your application. Mismatched audience claims are a common configuration issue</li>
                <li><strong>Never log JWTs in production:</strong> While this tool is safe and private, avoid logging tokens in production applications where they could be exposed in log files</li>
                <li><strong>Watch for custom claims:</strong> Different applications add custom claims beyond standard ones. Document what custom claims your system uses to better understand decoded tokens</li>
                <li><strong>Use HTTPS always:</strong> JWTs offer no inherent security‚Äîthey're just formatted data. Always transmit JWTs over HTTPS to prevent interception</li>
            </ul>

            <h3>Frequently Asked Questions</h3>

            <p><strong>Q: Does this tool verify JWT signatures?</strong></p>
            <p>A: Yes! This tool now supports HS256 signature verification. You can verify JWT signatures signed with HMAC-SHA256 by entering your secret key in the Verify Signature section. The tool will validate whether the signature is authentic and the token hasn't been tampered with. Important: Only use test or development keys‚Äînever enter production secret keys in browser tools. For production tokens, always verify signatures on your secure server. Note: This tool currently supports HS256 only; RS256 and ES256 support may be added in future updates.</p>

            <p><strong>Q: How do I check if a JWT is expired?</strong></p>
            <p>A: JWTs contain an 'exp' claim that specifies the expiration time as a Unix timestamp (seconds since epoch). This tool automatically checks the expiration time and displays whether the token is valid or expired. Simply decode the JWT using this tool and look for the expiration status in the payload output. If the current time is greater than the exp value, the token is expired. Your server must also validate expiration before accepting the token.</p>

            <p><strong>Q: What are JWT claims and which ones matter?</strong></p>
            <p>A: JWT claims are pieces of information stored in the payload (the middle part of a JWT). Standard claims include: sub (subject/user ID), iss (issuer), aud (audience), exp (expiration time), iat (issued at time), nbf (not before time), and jti (unique identifier). Custom claims specific to your application can also be included. When debugging tokens, check the 'exp' and 'sub' claims first to verify the token isn't expired and belongs to the correct user.</p>

            <p><strong>Q: Can I modify or create a JWT with this tool?</strong></p>
            <p>A: No, this tool only decodes JWTs. You cannot modify or create new tokens here. To create or modify JWTs, use backend code or specialized JWT tools that handle signing. Any JWT created without the proper signature will be rejected by your server. If you decode a JWT and want to see how changes would affect it, modify the payload values conceptually and re-encode manually, but understand this wouldn't be a valid token without proper signing.</p>

            <p><strong>Q: When and why should I use JWTs for authentication?</strong></p>
            <p>A: JWTs are ideal for stateless authentication in modern web and mobile applications, APIs, and microservices. They contain all user information in the token itself, eliminating the need for server-side session storage. JWTs are URL-safe, can be easily transmitted in headers, and work well with CORS and cross-domain requests. However, JWTs require HTTPS to prevent interception, proper signature verification on the server, and careful management of sensitive information in the payload (don't include passwords or secrets).</p>

            <p><strong>Q: What are the three parts of a JWT and what do they mean?</strong></p>
            <p>A: A JWT has three parts separated by dots: Header (specifies token type and signing algorithm), Payload (contains the actual data/claims including user info and expiration), and Signature (cryptographically proves the token hasn't been tampered with). The header and payload are Base64-encoded and human-readable. The signature can only be verified with the secret key. This tool decodes and displays all three parts so you can inspect the data and signature value.</p>

            <p><strong>Q: What is the token history feature and how does it help?</strong></p>
            <p>A: Token history is a unique feature that lets you save up to 10 JWT tokens with custom labels for quick access during debugging. For example, you can save tokens labeled "Production API", "Staging Server", "Test User 1", etc. This eliminates the need to constantly re-paste tokens when switching between different environments or test accounts. Simply select a saved token from the dropdown to instantly load and decode it. This feature is stored locally in your browser and never sent to any server, maintaining complete privacy.</p>

            <h3>Understanding JWT Security</h3>
            <p>JWTs are not encrypted by default‚Äîthey are only Base64-encoded and signed. Anyone can decode a JWT to see its contents, which is why sensitive information like passwords should never be stored in JWT claims. The signature proves the token came from a trusted source and hasn't been modified, but only if verified with the correct signing key. Always use HTTPS when transmitting JWTs to prevent interception, and always verify signatures on your server before trusting the token's claims.</p>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 Code Utils. All rights reserved.</p>
        <p>Free developer utilities - 100% client-side processing</p>
    </footer>

    <script src="js/common.js"></script>
    <script>
        // Track this tool visit
        CodeUtils.RecentTools.add({
            id: 'jwt-decoder',
            name: 'JWT Decoder',
            url: 'jwt-decoder.html'
        });

        // DOM elements
        const inputJWT = document.getElementById('inputJWT');
        const headerOutput = document.getElementById('headerOutput');
        const payloadOutput = document.getElementById('payloadOutput');
        const signatureOutput = document.getElementById('signatureOutput');

        // Store decoded data
        let decodedData = {
            header: null,
            payload: null,
            signature: null
        };

        // Initialize message handler
        CodeUtils.Message.init('message');

        // Base64URL decode
        function base64UrlDecode(str) {
            // Replace URL-safe characters
            let base64 = str.replace(/-/g, '+').replace(/_/g, '/');
            // Pad with '=' if necessary
            const pad = base64.length % 4;
            if (pad) {
                base64 += '='.repeat(4 - pad);
            }
            // Decode
            try {
                return decodeURIComponent(atob(base64).split('').map(c => {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
            } catch (e) {
                return atob(base64);
            }
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleString() + ' (' + date.toISOString() + ')';
        }

        // Check if expired
        function isExpired(exp) {
            if (!exp) return null;
            return Date.now() > exp * 1000;
        }

        // Calculate time difference in human-readable format
        function getTimeDifference(timestamp) {
            const now = Date.now();
            const targetTime = timestamp * 1000;
            const diffMs = Math.abs(targetTime - now);

            const seconds = Math.floor(diffMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;
            if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''}`;
            if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''}`;
            return `${seconds} second${seconds !== 1 ? 's' : ''}`;
        }

        // Create expiration badge
        function createExpirationBadge(exp) {
            if (!exp) return '';

            const now = Date.now();
            const expTime = exp * 1000;
            const isExpiredNow = now > expTime;
            const timeUntilExpiry = expTime - now;
            const fiveMinutes = 5 * 60 * 1000;

            if (isExpiredNow) {
                const timeAgo = getTimeDifference(exp);
                return `<span class="badge badge-expired">‚úó Expired ${timeAgo} ago</span>`;
            } else if (timeUntilExpiry < fiveMinutes) {
                const timeLeft = getTimeDifference(exp);
                return `<span class="badge badge-expiring">‚ö† Expires in ${timeLeft}</span>`;
            } else {
                const timeLeft = getTimeDifference(exp);
                return `<span class="badge badge-valid">‚úì Valid (${timeLeft} remaining)</span>`;
            }
        }

        // Claim descriptions for tooltips
        const claimDescriptions = {
            'sub': 'Subject - The unique identifier of the user or entity this token represents',
            'iss': 'Issuer - The entity that issued and signed the JWT (e.g., your auth server URL)',
            'aud': 'Audience - The intended recipient(s) of the token (e.g., your application ID)',
            'exp': 'Expiration Time - Unix timestamp when this token expires and should no longer be accepted',
            'iat': 'Issued At - Unix timestamp when this token was created',
            'nbf': 'Not Before - Unix timestamp before which the token should not be accepted',
            'jti': 'JWT ID - Unique identifier for this token, used to prevent replay attacks',
            'scope': 'Scope - Permissions or access levels granted to the bearer of this token',
            'roles': 'Roles - User roles or groups for authorization purposes',
            'email': 'Email - Email address of the user',
            'name': 'Name - Full name of the user',
            'username': 'Username - Username of the user',
            'admin': 'Admin - Whether the user has admin privileges'
        };

        // Create tooltip HTML
        function createTooltip(claim) {
            const description = claimDescriptions[claim];
            if (!description) return '';
            return `<span class="tooltip">?<span class="tooltiptext">${description}</span></span>`;
        }

        // Format claim with tooltip
        function formatClaimWithTooltip(claim, value) {
            const tooltip = createTooltip(claim);
            let formattedValue = value;

            // Format timestamps
            if ((claim === 'exp' || claim === 'iat' || claim === 'nbf') && typeof value === 'number') {
                formattedValue = formatTimestamp(value);
            }

            return `  "${claim}": ${JSON.stringify(value)}${tooltip ? ' ' + tooltip : ''}`;
        }

        // Decode JWT
        function decodeJWT() {
            const token = inputJWT.value.trim();
            if (!token) {
                CodeUtils.Message.error('Please enter a JWT token');
                return;
            }

            const parts = token.split('.');
            if (parts.length !== 3) {
                CodeUtils.Message.error('Invalid JWT format. JWT should have 3 parts separated by dots.');
                return;
            }

            try {
                // Decode header
                const headerStr = base64UrlDecode(parts[0]);
                decodedData.header = JSON.parse(headerStr);
                headerOutput.textContent = JSON.stringify(decodedData.header, null, 2);

                // Decode payload
                const payloadStr = base64UrlDecode(parts[1]);
                decodedData.payload = JSON.parse(payloadStr);

                // Format payload with tooltips
                const payloadLines = [];
                payloadLines.push('{');
                const claims = Object.keys(decodedData.payload);
                claims.forEach((claim, index) => {
                    const value = decodedData.payload[claim];
                    const isLast = index === claims.length - 1;
                    const tooltip = createTooltip(claim);
                    let valueStr;

                    // Format timestamps
                    if ((claim === 'exp' || claim === 'iat' || claim === 'nbf') && typeof value === 'number') {
                        valueStr = `${value} (${formatTimestamp(value)})`;
                    } else {
                        valueStr = JSON.stringify(value);
                    }

                    payloadLines.push(`  "${claim}": ${valueStr}${isLast ? '' : ','}`);
                });
                payloadLines.push('}');

                let payloadDisplay = payloadLines.join('\n');

                // Add expiry status with badge
                if (decodedData.payload.exp) {
                    const badge = createExpirationBadge(decodedData.payload.exp);
                    payloadDisplay += '\n\n--- Token Status ---\n';
                    payloadDisplay += 'Expires: ' + formatTimestamp(decodedData.payload.exp);
                }

                if (decodedData.payload.iat) {
                    if (!payloadDisplay.includes('--- Token Status ---')) {
                        payloadDisplay += '\n\n--- Token Status ---\n';
                    } else {
                        payloadDisplay += '\n';
                    }
                    payloadDisplay += 'Issued: ' + formatTimestamp(decodedData.payload.iat);
                }

                // Clear and set payload output
                payloadOutput.innerHTML = '';
                const textNode = document.createTextNode(payloadDisplay);
                payloadOutput.appendChild(textNode);

                // Add badge if expiration exists
                if (decodedData.payload.exp) {
                    const badge = createExpirationBadge(decodedData.payload.exp);
                    const badgeContainer = document.createElement('div');
                    badgeContainer.style.marginTop = 'var(--spacing-sm)';
                    badgeContainer.innerHTML = badge;
                    payloadOutput.appendChild(badgeContainer);
                }

                // Add claim explanations for standard claims
                const standardClaims = Object.keys(decodedData.payload).filter(claim => claimDescriptions[claim]);
                if (standardClaims.length > 0) {
                    const explanationsContainer = document.createElement('div');
                    explanationsContainer.style.marginTop = 'var(--spacing-md)';
                    explanationsContainer.style.padding = 'var(--spacing-sm)';
                    explanationsContainer.style.background = 'var(--bg-secondary)';
                    explanationsContainer.style.borderRadius = 'var(--radius)';
                    explanationsContainer.style.fontSize = '0.875rem';

                    let explanationsHtml = '<div style="font-weight: 600; margin-bottom: var(--spacing-xs); color: var(--primary);">üìñ Claim Explanations:</div>';
                    standardClaims.forEach(claim => {
                        const value = decodedData.payload[claim];
                        explanationsHtml += `<div style="margin: var(--spacing-xs) 0; padding: var(--spacing-xs); background: var(--bg-primary); border-radius: var(--radius);">`;
                        explanationsHtml += `<strong style="color: var(--primary);">${claim}:</strong> ${claimDescriptions[claim]}`;
                        explanationsHtml += `</div>`;
                    });

                    explanationsContainer.innerHTML = explanationsHtml;
                    payloadOutput.appendChild(explanationsContainer);
                }

                // Show signature (cannot decode, just display)
                decodedData.signature = parts[2];
                signatureOutput.textContent = parts[2];

                CodeUtils.Message.success('JWT decoded successfully!');

            } catch (error) {
                CodeUtils.Message.error('Error decoding JWT: ' + error.message);
                headerOutput.textContent = 'Error decoding header';
                payloadOutput.textContent = 'Error decoding payload';
                signatureOutput.textContent = '';
            }
        }

        // Copy section
        async function copySection(section) {
            let content;
            switch (section) {
                case 'header':
                    content = decodedData.header ? JSON.stringify(decodedData.header, null, 2) : '';
                    break;
                case 'payload':
                    content = decodedData.payload ? JSON.stringify(decodedData.payload, null, 2) : '';
                    break;
                case 'signature':
                    content = decodedData.signature || '';
                    break;
            }

            if (!content) {
                CodeUtils.Message.error('Nothing to copy');
                return;
            }

            try {
                await CodeUtils.Clipboard.copy(content);
                CodeUtils.Message.success('Copied to clipboard!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        // Copy all decoded
        async function copyDecoded() {
            if (!decodedData.header || !decodedData.payload) {
                CodeUtils.Message.error('Nothing to copy. Decode a JWT first.');
                return;
            }

            const content = `=== HEADER ===\n${JSON.stringify(decodedData.header, null, 2)}\n\n=== PAYLOAD ===\n${JSON.stringify(decodedData.payload, null, 2)}\n\n=== SIGNATURE ===\n${decodedData.signature}`;

            try {
                await CodeUtils.Clipboard.copy(content);
                CodeUtils.Message.success('Copied to clipboard!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        // Load sample JWT
        function loadSample() {
            // Sample JWT (expired, for demo purposes)
            const sampleJWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE2MjQyNjIyfQ.POstGetfAytaZS82wHcjoTyoqhMyxXiWdR7Nn7A29DNSl0EiXLdwJ6xC6AfgZWF1bOsS_TuYI3OG85AmiExREkrS6tDfTQ2B3WXlrr-wp5AokiRbz3_oB4OxG-W9KcEEbDRcZc0nH3L7LzYptiy1PtAylQGxHTWZXtGz4ht0bAecBgmpdgXMguEIcoqPJ1n3pIWk_dUZegpqx0Lka21H6XxUTxiy8OcaarA8zdnPUnV6AmNP3ecFawIFYdvJB_cm-GvpCSbr8G8y_Mllj8f4x9nBH8pQux89_6gUY618iYv7tuPWBFfEbLxtF2pZS6YC1aSfLQxeNe8djT9YjpvRZA';
            inputJWT.value = sampleJWT;
            decodeJWT();
        }

        // Clear all
        function clearAll() {
            inputJWT.value = '';
            headerOutput.textContent = 'Decoded header will appear here...';
            payloadOutput.textContent = 'Decoded payload will appear here...';
            signatureOutput.textContent = 'Signature will appear here...';
            decodedData = { header: null, payload: null, signature: null };
            CodeUtils.Message.hide();
        }

        // Token History Management
        const TOKEN_HISTORY_KEY = 'jwt_token_history';
        const MAX_HISTORY_SIZE = 10;

        function getTokenHistory() {
            try {
                const history = localStorage.getItem(TOKEN_HISTORY_KEY);
                return history ? JSON.parse(history) : [];
            } catch (e) {
                return [];
            }
        }

        function saveTokenHistory(history) {
            try {
                localStorage.setItem(TOKEN_HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                CodeUtils.Message.error('Failed to save token history');
            }
        }

        function updateHistoryDropdown() {
            const history = getTokenHistory();
            const select = document.getElementById('tokenHistorySelect');

            select.innerHTML = `<option value="">üìö Token History (${history.length} saved)</option>`;

            history.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                const preview = item.token.substring(0, 30) + '...';
                option.textContent = `${item.label} - ${preview}`;
                select.appendChild(option);
            });
        }

        function toggleSaveForm() {
            const form = document.getElementById('saveTokenForm');
            const input = document.getElementById('tokenLabel');
            form.style.display = form.style.display === 'none' ? 'flex' : 'none';
            if (form.style.display === 'flex') {
                input.focus();
            } else {
                input.value = '';
            }
        }

        function saveToken() {
            const token = inputJWT.value.trim();
            const label = document.getElementById('tokenLabel').value.trim();

            if (!token) {
                CodeUtils.Message.error('No token to save');
                return;
            }

            if (!label) {
                CodeUtils.Message.error('Please enter a label for the token');
                return;
            }

            const history = getTokenHistory();

            // Check if already exists
            const existingIndex = history.findIndex(item => item.token === token);
            if (existingIndex !== -1) {
                history[existingIndex].label = label;
                history[existingIndex].timestamp = Date.now();
            } else {
                // Add to beginning
                history.unshift({
                    label: label,
                    token: token,
                    timestamp: Date.now()
                });

                // Keep only MAX_HISTORY_SIZE items
                if (history.length > MAX_HISTORY_SIZE) {
                    history.pop();
                }
            }

            saveTokenHistory(history);
            updateHistoryDropdown();
            toggleSaveForm();
            CodeUtils.Message.success(`Token saved as "${label}"`);
        }

        function loadFromHistory() {
            const select = document.getElementById('tokenHistorySelect');
            const index = parseInt(select.value);

            if (isNaN(index)) return;

            const history = getTokenHistory();
            if (index < 0 || index >= history.length) return;

            inputJWT.value = history[index].token;
            decodeJWT();
            CodeUtils.Message.success(`Loaded token: ${history[index].label}`);
        }

        function clearHistory() {
            if (!confirm('Are you sure you want to clear all saved tokens?')) {
                return;
            }

            localStorage.removeItem(TOKEN_HISTORY_KEY);
            updateHistoryDropdown();
            CodeUtils.Message.success('Token history cleared');
        }

        // Auto-decode functionality
        let decodeTimeout = null;

        function autoDecodeOnInput() {
            const token = inputJWT.value.trim();

            // Clear previous timeout
            if (decodeTimeout) {
                clearTimeout(decodeTimeout);
            }

            // Check if it looks like a JWT (3 parts separated by dots)
            if (token && token.split('.').length === 3) {
                decodeTimeout = setTimeout(() => {
                    decodeJWT();
                }, 500);
            }
        }

        // Signature Verification
        function toggleVerifySection() {
            const content = document.getElementById('verifyContent');
            const icon = document.getElementById('verifyCollapseIcon');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                icon.classList.add('collapsed');
            }
        }

        async function verifySignature() {
            const token = inputJWT.value.trim();
            const secret = document.getElementById('secretKey').value.trim();
            const resultDiv = document.getElementById('verifyResult');

            if (!token) {
                CodeUtils.Message.error('Please enter a JWT token first');
                return;
            }

            if (!secret) {
                CodeUtils.Message.error('Please enter a secret key');
                return;
            }

            const parts = token.split('.');
            if (parts.length !== 3) {
                CodeUtils.Message.error('Invalid JWT format');
                return;
            }

            try {
                // Get the data to sign (header.payload)
                const data = parts[0] + '.' + parts[1];
                const signature = parts[2];

                // Convert secret to key
                const encoder = new TextEncoder();
                const keyData = encoder.encode(secret);
                const key = await crypto.subtle.importKey(
                    'raw',
                    keyData,
                    { name: 'HMAC', hash: 'SHA-256' },
                    false,
                    ['sign']
                );

                // Sign the data
                const signatureBuffer = await crypto.subtle.sign('HMAC', key, encoder.encode(data));

                // Convert to base64url
                const signatureArray = new Uint8Array(signatureBuffer);
                let binary = '';
                for (let i = 0; i < signatureArray.length; i++) {
                    binary += String.fromCharCode(signatureArray[i]);
                }
                const base64 = btoa(binary);
                const base64url = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');

                // Compare signatures
                if (base64url === signature) {
                    resultDiv.innerHTML = '<div class="verify-result valid">‚úì Signature is valid! Token has not been tampered with.</div>';
                    CodeUtils.Message.success('Signature verified successfully!');
                } else {
                    resultDiv.innerHTML = '<div class="verify-result invalid">‚úó Invalid signature! Token may have been tampered with or wrong secret key.</div>';
                    CodeUtils.Message.warning('Signature verification failed');
                }

            } catch (error) {
                resultDiv.innerHTML = '<div class="verify-result invalid">‚úó Verification error: ' + error.message + '</div>';
                CodeUtils.Message.error('Verification failed: ' + error.message);
            }
        }

        // Initialize
        updateHistoryDropdown();

        // Keyboard shortcuts
        CodeUtils.Shortcuts.register('Enter', decodeJWT, true);
        CodeUtils.Shortcuts.register('k', copyDecoded, true);

        // Auto-decode on paste
        inputJWT.addEventListener('paste', () => {
            setTimeout(decodeJWT, 100);
        });

        // Auto-decode on input (debounced)
        inputJWT.addEventListener('input', autoDecodeOnInput);

        // Allow Enter key in save token label input
        document.getElementById('tokenLabel').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveToken();
            }
        });
    </script>
</body>
</html>
