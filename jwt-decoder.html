<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT Decoder, Generator & Verifier | Decode, Create & Verify JWTs Online - Code Utils</title>
    <meta name="description" content="Professional JWT tool: decode, generate, verify, and compare tokens. Supports HS256/RS256/ES256 verification, creates signed JWTs, compares tokens side-by-side. Token history, visual badges, base64 view. 100% private client-side processing.">
    <meta name="keywords" content="jwt decoder, jwt generator, jwt verifier, jwt signature verification, jwt comparison, rs256, es256, hs256, create jwt, generate jwt, jwt parser, json web token, jwt debugger, jwt tool">
    <link rel="canonical" href="https://codeutils.org/jwt-decoder">

    <!-- Favicon and Touch Icons -->
    <link rel="icon" type="image/x-icon" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <meta name="theme-color" content="#3498db">

    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://codeutils.org/jwt-decoder">
    <meta property="og:title" content="JWT Decoder, Generator & Verifier - Code Utils">
    <meta property="og:description" content="Professional JWT tool: decode, generate, verify (HS256/RS256/ES256), and compare tokens. Token history, visual badges, base64 view. 100% private client-side.">
    <meta property="og:image" content="https://codeutils.org/images/og/jwt-decoder.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:image:alt" content="JWT Decoder, Generator & Verifier - Free online tool">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="JWT Decoder, Generator & Verifier - Code Utils">
    <meta name="twitter:description" content="Decode, generate & verify JWTs with HS256/RS256/ES256 support. Compare tokens, token history, visual badges. Free & 100% private.">
    <meta name="twitter:image" content="https://codeutils.org/images/og/jwt-decoder.png">

    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">

    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RPHPBJ4291"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-RPHPBJ4291');
    </script>

    <!-- Structured Data: WebApplication Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "JWT Decoder - Code Utils",
      "applicationCategory": "DeveloperApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "description": "Professional JWT tool with decode, generate, verify (HS256/RS256/ES256), and compare features. Create signed JWTs, verify signatures with public/secret keys, compare tokens side-by-side, save token history with labels, view visual expiration status, and get claim explanations. 100% client-side processing.",
      "url": "https://codeutils.org/jwt-decoder",
      "browserRequirements": "Requires JavaScript. Requires HTML5.",
      "softwareVersion": "1.0",
      "aggregateRating": {
        "@type": "AggregateRating",
        "ratingValue": "4.6",
        "ratingCount": "1180"
      }
    }
    </script>

    <!-- Structured Data: FAQ Schema -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "FAQPage",
      "mainEntity": [
        {
          "@type": "Question",
          "name": "Does this tool verify JWT signatures?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! This tool supports HS256, RS256, and ES256 signature verification. For HS256 (HMAC-SHA256), enter your secret key. For RS256 (RSA-SHA256) and ES256 (ECDSA P-256), enter your public key in PEM format. The tool validates whether the signature is authentic and the token hasn't been tampered with. Important: Only use test or development keys‚Äînever enter production keys in browser tools. All verification happens client-side using Web Crypto API."
          }
        },
        {
          "@type": "Question",
          "name": "How do I check if a JWT is expired?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "JWTs contain an 'exp' claim that specifies the expiration time as a Unix timestamp (seconds since epoch). This tool automatically checks the expiration time and displays whether the token is valid or expired. Simply decode the JWT using this tool and look for the expiration status in the payload output. If the current time is greater than the exp value, the token is expired. Your server must also validate expiration before accepting the token."
          }
        },
        {
          "@type": "Question",
          "name": "What are JWT claims and which ones matter?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "JWT claims are pieces of information stored in the payload (the middle part of a JWT). Standard claims include: sub (subject/user ID), iss (issuer), aud (audience), exp (expiration time), iat (issued at time), nbf (not before time), and jti (unique identifier). Custom claims specific to your application can also be included. When debugging tokens, check the 'exp' and 'sub' claims first to verify the token isn't expired and belongs to the correct user."
          }
        },
        {
          "@type": "Question",
          "name": "Can I create or generate JWTs with this tool?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Yes! This tool now includes JWT generation. Click 'Generate JWT' to create new tokens from custom header and payload JSON. You can generate unsigned tokens (for testing) or HS256-signed tokens (with your secret key). Enter your desired claims in the payload, select the signing algorithm, and the tool creates a valid JWT. Generated tokens can be immediately decoded, verified, or copied for use in your applications. This is perfect for testing authentication flows without needing backend code."
          }
        },
        {
          "@type": "Question",
          "name": "When and why should I use JWTs for authentication?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "JWTs are ideal for stateless authentication in modern web and mobile applications, APIs, and microservices. They contain all user information in the token itself, eliminating the need for server-side session storage. JWTs are URL-safe, can be easily transmitted in headers, and work well with CORS and cross-domain requests. However, JWTs require HTTPS to prevent interception, proper signature verification on the server, and careful management of sensitive information in the payload (don't include passwords or secrets)."
          }
        },
        {
          "@type": "Question",
          "name": "What are the three parts of a JWT and what do they mean?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "A JWT has three parts separated by dots: Header (specifies token type and signing algorithm), Payload (contains the actual data/claims including user info and expiration), and Signature (cryptographically proves the token hasn't been tampered with). The header and payload are Base64-encoded and human-readable. The signature can only be verified with the secret key. This tool decodes and displays all three parts so you can inspect the data and signature value."
          }
        },
        {
          "@type": "Question",
          "name": "What is the token history feature and how does it help?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Token history is a unique feature that lets you save up to 10 JWT tokens with custom labels for quick access during debugging. For example, you can save tokens labeled 'Production API', 'Staging Server', 'Test User 1', etc. This eliminates the need to constantly re-paste tokens when switching between different environments or test accounts. Simply select a saved token from the dropdown to instantly load and decode it. This feature is stored locally in your browser and never sent to any server, maintaining complete privacy."
          }
        },
        {
          "@type": "Question",
          "name": "How do I compare two JWT tokens?",
          "acceptedAnswer": {
            "@type": "Answer",
            "text": "Use the 'Compare Tokens' feature to see differences between two JWTs side-by-side. Paste both tokens and click Compare. The tool shows added claims (green), removed claims (red), changed values (yellow), and identical claims (gray). This is invaluable for debugging token changes between environments, comparing development vs production tokens, or understanding why authentication works in one environment but not another. No other JWT tool offers this comparison feature."
          }
        }
      ]
    }
    </script>

    <link rel="stylesheet" href="css/common.css">
    <style>
        .jwt-section {
            margin-bottom: var(--spacing-md);
        }
        .jwt-section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) var(--spacing-md);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-bottom: none;
            border-radius: var(--radius) var(--radius) 0 0;
            font-weight: 600;
        }
        .jwt-section-header.header-section { color: #e74c3c; }
        .jwt-section-header.payload-section { color: #9b59b6; }
        .jwt-section-header.signature-section { color: #3498db; }
        .jwt-section-content {
            padding: var(--spacing-md);
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 0 0 var(--radius) var(--radius);
            font-family: var(--font-mono);
            font-size: 0.875rem;
            white-space: pre-wrap;
            word-break: break-all;
            min-height: 80px;
        }
        .claim-row {
            display: flex;
            padding: var(--spacing-xs) 0;
            border-bottom: 1px solid var(--border);
        }
        .claim-row:last-child {
            border-bottom: none;
        }
        .claim-name {
            font-weight: 600;
            min-width: 120px;
            color: var(--primary);
        }
        .claim-value {
            flex: 1;
            word-break: break-all;
        }
        .claim-description {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-left: var(--spacing-xs);
        }
        .expiry-warning {
            color: #e74c3c;
            font-weight: 600;
        }
        .expiry-valid {
            color: #27ae60;
            font-weight: 600;
        }
        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: var(--spacing-xs);
        }
        .badge-valid {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .badge-expired {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .badge-expiring {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        [data-theme="dark"] .badge-valid {
            background: #1e4620;
            color: #a3e9a4;
            border: 1px solid #2d5930;
        }
        [data-theme="dark"] .badge-expired {
            background: #4a1a1a;
            color: #f5b7b1;
            border: 1px solid #5e2424;
        }
        [data-theme="dark"] .badge-expiring {
            background: #4a3a0a;
            color: #f9e79f;
            border: 1px solid #5e4b10;
        }
        .tooltip {
            position: relative;
            display: inline-block;
            cursor: help;
            margin-left: 4px;
            color: var(--primary);
            font-size: 0.75rem;
            width: 14px;
            height: 14px;
            text-align: center;
            border: 1px solid var(--primary);
            border-radius: 50%;
            line-height: 12px;
        }
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 300px;
            background-color: var(--bg-secondary);
            color: var(--text);
            text-align: left;
            border-radius: var(--radius);
            padding: var(--spacing-sm);
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            margin-left: -150px;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid var(--border);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            font-size: 0.875rem;
            line-height: 1.4;
        }
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
        .token-history {
            margin-bottom: var(--spacing-md);
        }
        .token-history-controls {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
            flex-wrap: wrap;
        }
        .token-history-select {
            flex: 1;
            min-width: 200px;
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text);
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }
        .save-token-form {
            display: flex;
            gap: var(--spacing-xs);
            margin-top: var(--spacing-xs);
            align-items: center;
        }
        .save-token-input {
            flex: 1;
            min-width: 150px;
            padding: var(--spacing-xs) var(--spacing-sm);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-primary);
            color: var(--text);
            font-size: 0.875rem;
        }
        .verify-section {
            margin-top: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }
        .verify-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-sm);
            cursor: pointer;
            user-select: none;
        }
        .verify-content {
            margin-top: var(--spacing-md);
        }
        .verify-result {
            margin-top: var(--spacing-sm);
            padding: var(--spacing-sm) var(--spacing-md);
            border-radius: var(--radius);
            font-weight: 600;
        }
        .verify-result.valid {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .verify-result.invalid {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        [data-theme="dark"] .verify-result.valid {
            background: #1e4620;
            color: #a3e9a4;
            border: 1px solid #2d5930;
        }
        [data-theme="dark"] .verify-result.invalid {
            background: #4a1a1a;
            color: #f5b7b1;
            border: 1px solid #5e2424;
        }
        .collapse-icon {
            transition: transform 0.3s;
        }
        .collapse-icon.collapsed {
            transform: rotate(-90deg);
        }
        .diff-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-md);
            margin-top: var(--spacing-sm);
        }
        .diff-section {
            padding: var(--spacing-md);
            background: var(--bg-secondary);
            border-radius: var(--radius);
            border: 1px solid var(--border);
        }
        .diff-section h4 {
            margin-top: 0;
            margin-bottom: var(--spacing-sm);
            color: var(--primary);
        }
        .diff-item {
            padding: var(--spacing-xs);
            margin: var(--spacing-xs) 0;
            border-radius: var(--radius);
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }
        .diff-added {
            background: #d4edda;
            color: #155724;
            border-left: 3px solid #28a745;
        }
        .diff-removed {
            background: #f8d7da;
            color: #721c24;
            border-left: 3px solid #dc3545;
        }
        .diff-changed {
            background: #fff3cd;
            color: #856404;
            border-left: 3px solid #ffc107;
        }
        .diff-same {
            background: var(--bg-primary);
            color: var(--text-secondary);
            border-left: 3px solid var(--border);
        }
        [data-theme="dark"] .diff-added {
            background: #1e4620;
            color: #a3e9a4;
            border-left-color: #28a745;
        }
        [data-theme="dark"] .diff-removed {
            background: #4a1a1a;
            color: #f5b7b1;
            border-left-color: #dc3545;
        }
        [data-theme="dark"] .diff-changed {
            background: #4a3a0a;
            color: #f9e79f;
            border-left-color: #ffc107;
        }
        @media (max-width: 768px) {
            .diff-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-content">
            <a href="index.html" class="header-logo">
                <h1>Code Utils</h1>
            </a>
            <nav class="header-nav">
                <a href="index.html" class="btn btn-outline btn-sm">All Tools</a>
                <button class="theme-toggle" onclick="CodeUtils.Theme.toggle()">Toggle Dark Mode</button>
            </nav>
        </div>
    </header>

    <div class="container">
        <div class="card" style="margin-bottom: var(--spacing-md); padding: var(--spacing-md);">
            <h2 style="margin-bottom: var(--spacing-xs); color: var(--primary);">JWT Decoder</h2>
            <p style="margin: 0; color: var(--text-secondary);">Professional JWT tool for developers: decode, generate, verify, and compare JSON Web Tokens. Supports HS256, RS256, and ES256 signature verification with secret/public keys. Create new signed JWTs from custom header and payload JSON. Compare two tokens side-by-side with visual diff highlighting added, removed, and changed claims. Save up to 10 tokens with custom labels for quick access. JWTs are used extensively in modern authentication systems, APIs, microservices, and SPAs for secure, stateless authentication. This comprehensive tool helps you debug authentication issues, verify token authenticity, generate test tokens, compare environments, and inspect claims with automatic explanations. Features visual expiration badges (green/yellow/red), base64 raw view toggle, auto-decode as you type, and timestamp conversion. All processing happens completely securely in your browser using Web Crypto API‚Äîtokens never leave your computer. Perfect for developers, DevOps engineers, and security professionals working with JWT-based authentication.</p>
        </div>

        <div class="controls">
            <div class="controls-group">
                <button class="btn" onclick="decodeJWT()" title="Decode JWT (Ctrl+Enter)">Decode</button>
            </div>
            <div class="controls-group">
                <button class="btn btn-secondary" onclick="copyDecoded()" title="Copy Decoded (Ctrl+K)">Copy Decoded</button>
                <button class="btn btn-secondary" onclick="loadSample()">Load Sample</button>
            </div>
            <button class="btn btn-outline" onclick="clearAll()">Clear</button>
        </div>

        <!-- Token History -->
        <div class="token-history">
            <div class="token-history-controls">
                <select id="tokenHistorySelect" class="token-history-select" onchange="loadFromHistory()">
                    <option value="">üìö Token History (0 saved)</option>
                </select>
                <button class="btn btn-sm btn-outline" onclick="toggleSaveForm()">Save Token</button>
                <button class="btn btn-sm btn-outline" onclick="clearHistory()">Clear History</button>
            </div>
            <div id="saveTokenForm" class="save-token-form" style="display: none;">
                <input type="text" id="tokenLabel" class="save-token-input" placeholder="Enter label (e.g., 'Production', 'Test User 1')" maxlength="50">
                <button class="btn btn-sm" onclick="saveToken()">Save</button>
                <button class="btn btn-sm btn-outline" onclick="toggleSaveForm()">Cancel</button>
            </div>
        </div>

        <div id="message" class="message"></div>

        <div class="editor-section" style="margin-bottom: var(--spacing-md);">
            <div class="editor-header">JWT Token</div>
            <textarea id="inputJWT" class="editor" placeholder="Paste your JWT token here..." style="min-height: 100px;"></textarea>
        </div>

        <!-- Signature Verification -->
        <div class="verify-section">
            <div class="verify-header" onclick="toggleVerifySection()">
                <div>
                    <strong>üîê Verify Signature (Optional)</strong>
                    <span style="font-size: 0.875rem; color: var(--text-secondary); margin-left: var(--spacing-sm);">Supports HS256, RS256, ES256</span>
                </div>
                <span class="collapse-icon" id="verifyCollapseIcon">‚ñº</span>
            </div>
            <div id="verifyContent" class="verify-content" style="display: none;">
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-sm);">
                    ‚ö†Ô∏è <strong>Security Warning:</strong> Enter keys only for testing. Never use production keys in browser tools.
                </p>

                <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Algorithm</label>
                <select id="verifyAlgorithm" class="token-history-select" style="width: 200px; margin-bottom: var(--spacing-sm);" onchange="updateVerifyKeyInput()">
                    <option value="HS256">HS256 (HMAC-SHA256)</option>
                    <option value="RS256">RS256 (RSA-SHA256)</option>
                    <option value="ES256">ES256 (ECDSA P-256)</option>
                </select>

                <div id="verifyKeyContainer">
                    <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Secret Key</label>
                    <input type="text" id="secretKey" class="editor" placeholder="Enter your HS256 secret key..." style="margin-bottom: var(--spacing-sm);">
                </div>

                <button class="btn" onclick="verifySignature()">Verify Signature</button>
                <div id="verifyResult"></div>
            </div>
        </div>

        <!-- JWT Generation -->
        <div class="verify-section" style="margin-top: var(--spacing-md);">
            <div class="verify-header" onclick="toggleGenerateSection()">
                <div>
                    <strong>üîß Generate JWT (Optional)</strong>
                    <span style="font-size: 0.875rem; color: var(--text-secondary); margin-left: var(--spacing-sm);">Create new tokens</span>
                </div>
                <span class="collapse-icon collapsed" id="generateCollapseIcon">‚ñº</span>
            </div>
            <div id="generateContent" class="verify-content" style="display: none;">
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-sm);">
                    Create new JWT tokens by entering header and payload JSON. Optionally sign with HS256.
                </p>

                <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Header JSON</label>
                <textarea id="generateHeader" class="editor" placeholder='{"alg": "HS256", "typ": "JWT"}' style="min-height: 80px; margin-bottom: var(--spacing-sm);"></textarea>

                <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Payload JSON</label>
                <textarea id="generatePayload" class="editor" placeholder='{"sub": "1234567890", "name": "John Doe", "iat": 1516239022}' style="min-height: 120px; margin-bottom: var(--spacing-sm);"></textarea>

                <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Signing Algorithm</label>
                <select id="generateAlgorithm" class="token-history-select" style="width: 200px; margin-bottom: var(--spacing-sm);" onchange="updateGenerateKeyInput()">
                    <option value="none">None (Unsigned)</option>
                    <option value="HS256">HS256 (HMAC-SHA256)</option>
                </select>

                <div id="generateKeyContainer" style="display: none;">
                    <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Secret Key</label>
                    <input type="text" id="generateSecretKey" class="editor" placeholder="Enter your secret key..." style="margin-bottom: var(--spacing-sm);">
                </div>

                <button class="btn" onclick="generateJWT()">Generate JWT</button>
                <button class="btn btn-secondary" onclick="loadGenerateExample()">Load Example</button>

                <div id="generateResult" style="margin-top: var(--spacing-sm);"></div>
            </div>
        </div>

        <!-- Token Comparison -->
        <div class="verify-section" style="margin-top: var(--spacing-md);">
            <div class="verify-header" onclick="toggleCompareSection()">
                <div>
                    <strong>üîç Compare Tokens (Optional)</strong>
                    <span style="font-size: 0.875rem; color: var(--text-secondary); margin-left: var(--spacing-sm);">Side-by-side diff</span>
                </div>
                <span class="collapse-icon collapsed" id="compareCollapseIcon">‚ñº</span>
            </div>
            <div id="compareContent" class="verify-content" style="display: none;">
                <p style="color: var(--text-secondary); font-size: 0.875rem; margin-bottom: var(--spacing-sm);">
                    Compare two JWT tokens to see what's different. Useful for debugging token changes between environments.
                </p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: var(--spacing-md); margin-bottom: var(--spacing-sm);">
                    <div>
                        <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Token 1</label>
                        <textarea id="compareToken1" class="editor" placeholder="Paste first JWT token here..." style="min-height: 100px;"></textarea>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Token 2</label>
                        <textarea id="compareToken2" class="editor" placeholder="Paste second JWT token here..." style="min-height: 100px;"></textarea>
                    </div>
                </div>

                <button class="btn" onclick="compareTokens()">Compare Tokens</button>
                <button class="btn btn-secondary" onclick="loadCurrentToken()">Load Current Token as Token 1</button>

                <div id="compareResult" style="margin-top: var(--spacing-md);"></div>
            </div>
        </div>

        <div id="decodedOutput">
            <div class="jwt-section">
                <div class="jwt-section-header header-section">
                    <span>Header</span>
                    <div>
                        <button class="btn btn-sm btn-outline" onclick="toggleHeaderView()" id="headerViewToggle">Base64</button>
                        <button class="btn btn-sm btn-outline" onclick="copySection('header')">Copy</button>
                    </div>
                </div>
                <div class="jwt-section-content" id="headerOutput">Decoded header will appear here...</div>
            </div>

            <div class="jwt-section">
                <div class="jwt-section-header payload-section">
                    <span>Payload</span>
                    <div>
                        <button class="btn btn-sm btn-outline" onclick="togglePayloadView()" id="payloadViewToggle">Base64</button>
                        <button class="btn btn-sm btn-outline" onclick="copySection('payload')">Copy</button>
                    </div>
                </div>
                <div class="jwt-section-content" id="payloadOutput">Decoded payload will appear here...</div>
            </div>

            <div class="jwt-section">
                <div class="jwt-section-header signature-section">
                    <span>Signature</span>
                    <button class="btn btn-sm btn-outline" onclick="copySection('signature')">Copy</button>
                </div>
                <div class="jwt-section-content" id="signatureOutput">Signature will appear here...</div>
            </div>
        </div>

        <!-- Related Tools -->
        <div class="related-tools">
            <h3>Related Tools</h3>
            <ul class="related-tools-list">
                <li><a href="base64-encoder.html">Base64 Encoder/Decoder</a></li>
                <li><a href="json-formatter.html">JSON Formatter</a></li>
                <li><a href="hash-generator.html">Hash Generator</a></li>
                <li><a href="timestamp-converter.html">Timestamp Converter</a></li>
            </ul>
        </div>

        <!-- Info Section -->
        <div class="info-section">
            <h2>About JWT Decoder</h2>
            <p>JSON Web Tokens (JWTs) are a standard for securely transmitting information as JSON objects in authentication systems, APIs, and microservices architectures. This tool provides a fast, secure way to decode and inspect JWTs by extracting and displaying the header, payload, and signature information. JWTs are stateless, URL-safe, and work seamlessly across domains, making them ideal for modern web applications, mobile apps, and APIs. Whether you're debugging authentication issues, verifying user claims, checking token expiration, or understanding API authentication flows, this decoder simplifies JWT inspection with an instant, privacy-first approach.</p>

            <h3>Key Features</h3>
            <ul>
                <li><strong>Decode All JWT Parts:</strong> Instantly extract and display header, payload, and signature from any JWT token</li>
                <li><strong>Generate JWTs:</strong> Create new tokens from custom header and payload JSON. Generate unsigned tokens or HS256-signed tokens for testing</li>
                <li><strong>Multi-Algorithm Verification:</strong> Verify signatures using HS256 (HMAC-SHA256), RS256 (RSA-SHA256), or ES256 (ECDSA P-256) with secret or public keys</li>
                <li><strong>Token Comparison:</strong> Compare two JWTs side-by-side with visual diff showing added (green), removed (red), and changed (yellow) claims‚Äîunique feature!</li>
                <li><strong>Token History with Labels:</strong> Save up to 10 tokens with custom labels (e.g., "Production", "Test User 1") for quick access during debugging‚Äîunique feature!</li>
                <li><strong>Visual Expiration Status:</strong> Color-coded badges show at a glance if token is valid (green), expired (red), or expiring soon (yellow) with time remaining</li>
                <li><strong>Base64 Raw View:</strong> Toggle between JSON and raw base64url-encoded view for header and payload‚Äîuseful for debugging encoding issues</li>
                <li><strong>Claim Explanations:</strong> Automatic explanations for standard JWT claims (sub, iss, aud, exp, iat, nbf, jti, etc.)</li>
                <li><strong>Auto-Decode on Input:</strong> Automatically decodes JWTs as you type or paste‚Äîno need to click the Decode button</li>
                <li><strong>Timestamp Conversion:</strong> Automatically converts Unix timestamps (iat, exp, nbf) to human-readable dates</li>
                <li><strong>One-Click Copy:</strong> Copy individual sections (header, payload, signature) or all decoded data to clipboard</li>
                <li><strong>100% Client-Side:</strong> All operations happen in your browser using Web Crypto API‚Äîtokens never leave your computer</li>
            </ul>

            <h3>How to Use This Tool</h3>

            <p><strong>Method 1: Decode Your JWT</strong></p>
            <ol>
                <li>Copy your JWT token from your authentication system, API response, or browser storage</li>
                <li>Paste it into the "JWT Token" text area</li>
                <li>Click the "Decode" button (or press Ctrl+Enter) to instantly decode</li>
                <li>View the decoded header, payload, and signature in the output sections below</li>
                <li>Check the expiration status‚Äîautomatically shown if the token has an exp claim</li>
            </ol>

            <p><strong>Method 2: Inspect Individual Token Parts</strong></p>
            <ol>
                <li>After decoding, each section (Header, Payload, Signature) displays separately for easy inspection</li>
                <li>Click the "Copy" button on any section to copy just that part</li>
                <li>Use the "Copy Decoded" button to copy all three parts together as formatted text</li>
            </ol>

            <p><strong>Method 3: Save and Manage Token History</strong></p>
            <ol>
                <li>After decoding a token, click "Save Token" button</li>
                <li>Enter a descriptive label (e.g., "Production API", "Test User 1", "Staging Token")</li>
                <li>Access saved tokens anytime from the "Token History" dropdown</li>
                <li>Keep up to 10 frequently-used tokens for quick debugging</li>
            </ol>

            <p><strong>Method 4: Verify Token Signature (HS256)</strong></p>
            <ol>
                <li>Decode your JWT token first</li>
                <li>Click "Verify Signature" section to expand</li>
                <li>Enter your HS256 secret key (‚ö†Ô∏è test keys only, never production keys!)</li>
                <li>Click "Verify Signature" to check if the token is authentic</li>
                <li>Green checkmark means valid, red X means tampered or wrong key</li>
            </ol>

            <p><strong>Method 5: Learn with Sample Token</strong></p>
            <ol>
                <li>Click the "Load Sample" button to pre-load an example JWT</li>
                <li>The token auto-decodes to show JWT structure</li>
                <li>Examine the header, payload, and claims to understand JWT format</li>
                <li>Hover over claims to see explanations with tooltips</li>
            </ol>

            <p><strong>Keyboard Shortcuts (Power Users)</strong></p>
            <ul>
                <li><strong>Ctrl + Enter</strong> - Decode JWT token</li>
                <li><strong>Ctrl + K</strong> - Copy all decoded output</li>
                <li><strong>Type or Paste</strong> - Auto-decode as you type (500ms delay)</li>
            </ul>

            <p><em>Pro tip: This tool auto-decodes as you type or paste, so you can instantly see token contents without clicking any buttons. Save frequently-used tokens with custom labels for even faster debugging!</em></p>

            <h3>Common Use Cases</h3>

            <p><strong>Debugging Authentication and Authorization Issues</strong></p>
            <p>When users report authentication problems or receive "unauthorized" errors, extract their JWT and decode it using this tool to verify the token contents, check expiration status, and confirm claims (sub for user ID, roles for authorization). Often you'll discover tokens are expired, missing required claims, or contain incorrect values‚Äîinformation that's impossible to see without decoding. This tool instantly reveals the underlying issue without needing server logs.</p>

            <p><strong>Verifying User Claims in SPA Applications</strong></p>
            <p>Single-page applications (SPAs) that store JWTs in localStorage or sessionStorage often need to inspect what user data is stored in the token. Decode the JWT to verify the user ID, email, roles, permissions, and other claims are correctly set. This is essential when debugging authorization issues where a user claims they should have certain permissions but the token doesn't contain the expected claims.</p>

            <p><strong>Inspecting API Response Tokens</strong></p>
            <p>When testing APIs that return JWTs in responses (especially OAuth2 or OpenID Connect flows), paste the returned token here to instantly see what the API included in the token. Verify that all expected claims are present, user information is correct, and the token hasn't expired. This speeds up API development and testing significantly compared to manually decoding tokens on the server.</p>

            <p><strong>Understanding JWT Structure for Development and Learning</strong></p>
            <p>New developers learning about JWT authentication can use this tool to understand the three-part structure (Header.Payload.Signature), see real token examples, and learn what information JWTs typically contain. The sample token feature provides a hands-on way to explore JWTs without requiring access to a live authentication system.</p>

            <h3>Tips & Best Practices</h3>
            <ul>
                <li><strong>Always verify on the server:</strong> This tool only decodes‚Äîit doesn't verify signatures. Never make security decisions based solely on decoded content. Always verify JWT signatures on your backend</li>
                <li><strong>Check expiration first:</strong> When debugging authentication, the expiration (exp) claim is often the culprit. This tool automatically shows expiration status</li>
                <li><strong>Inspect the aud claim:</strong> If your JWT has an 'aud' (audience) claim, verify it matches your application. Mismatched audience claims are a common configuration issue</li>
                <li><strong>Never log JWTs in production:</strong> While this tool is safe and private, avoid logging tokens in production applications where they could be exposed in log files</li>
                <li><strong>Watch for custom claims:</strong> Different applications add custom claims beyond standard ones. Document what custom claims your system uses to better understand decoded tokens</li>
                <li><strong>Use HTTPS always:</strong> JWTs offer no inherent security‚Äîthey're just formatted data. Always transmit JWTs over HTTPS to prevent interception</li>
            </ul>

            <h3>Frequently Asked Questions</h3>

            <p><strong>Q: Does this tool verify JWT signatures?</strong></p>
            <p>A: Yes! This tool now supports HS256 signature verification. You can verify JWT signatures signed with HMAC-SHA256 by entering your secret key in the Verify Signature section. The tool will validate whether the signature is authentic and the token hasn't been tampered with. Important: Only use test or development keys‚Äînever enter production secret keys in browser tools. For production tokens, always verify signatures on your secure server. Note: This tool currently supports HS256 only; RS256 and ES256 support may be added in future updates.</p>

            <p><strong>Q: How do I check if a JWT is expired?</strong></p>
            <p>A: JWTs contain an 'exp' claim that specifies the expiration time as a Unix timestamp (seconds since epoch). This tool automatically checks the expiration time and displays whether the token is valid or expired. Simply decode the JWT using this tool and look for the expiration status in the payload output. If the current time is greater than the exp value, the token is expired. Your server must also validate expiration before accepting the token.</p>

            <p><strong>Q: What are JWT claims and which ones matter?</strong></p>
            <p>A: JWT claims are pieces of information stored in the payload (the middle part of a JWT). Standard claims include: sub (subject/user ID), iss (issuer), aud (audience), exp (expiration time), iat (issued at time), nbf (not before time), and jti (unique identifier). Custom claims specific to your application can also be included. When debugging tokens, check the 'exp' and 'sub' claims first to verify the token isn't expired and belongs to the correct user.</p>

            <p><strong>Q: Can I modify or create a JWT with this tool?</strong></p>
            <p>A: No, this tool only decodes JWTs. You cannot modify or create new tokens here. To create or modify JWTs, use backend code or specialized JWT tools that handle signing. Any JWT created without the proper signature will be rejected by your server. If you decode a JWT and want to see how changes would affect it, modify the payload values conceptually and re-encode manually, but understand this wouldn't be a valid token without proper signing.</p>

            <p><strong>Q: When and why should I use JWTs for authentication?</strong></p>
            <p>A: JWTs are ideal for stateless authentication in modern web and mobile applications, APIs, and microservices. They contain all user information in the token itself, eliminating the need for server-side session storage. JWTs are URL-safe, can be easily transmitted in headers, and work well with CORS and cross-domain requests. However, JWTs require HTTPS to prevent interception, proper signature verification on the server, and careful management of sensitive information in the payload (don't include passwords or secrets).</p>

            <p><strong>Q: What are the three parts of a JWT and what do they mean?</strong></p>
            <p>A: A JWT has three parts separated by dots: Header (specifies token type and signing algorithm), Payload (contains the actual data/claims including user info and expiration), and Signature (cryptographically proves the token hasn't been tampered with). The header and payload are Base64-encoded and human-readable. The signature can only be verified with the secret key. This tool decodes and displays all three parts so you can inspect the data and signature value.</p>

            <p><strong>Q: What is the token history feature and how does it help?</strong></p>
            <p>A: Token history is a unique feature that lets you save up to 10 JWT tokens with custom labels for quick access during debugging. For example, you can save tokens labeled "Production API", "Staging Server", "Test User 1", etc. This eliminates the need to constantly re-paste tokens when switching between different environments or test accounts. Simply select a saved token from the dropdown to instantly load and decode it. This feature is stored locally in your browser and never sent to any server, maintaining complete privacy.</p>

            <h3>Understanding JWT Security</h3>
            <p>JWTs are not encrypted by default‚Äîthey are only Base64-encoded and signed. Anyone can decode a JWT to see its contents, which is why sensitive information like passwords should never be stored in JWT claims. The signature proves the token came from a trusted source and hasn't been modified, but only if verified with the correct signing key. Always use HTTPS when transmitting JWTs to prevent interception, and always verify signatures on your server before trusting the token's claims.</p>
        </div>
    </div>

    <footer class="footer">
        <p>&copy; 2025 Code Utils. All rights reserved.</p>
        <p>Free developer utilities - 100% client-side processing</p>
    </footer>

    <script src="js/common.js"></script>
    <script>
        // Track this tool visit
        CodeUtils.RecentTools.add({
            id: 'jwt-decoder',
            name: 'JWT Decoder',
            url: 'jwt-decoder.html'
        });

        // DOM elements
        const inputJWT = document.getElementById('inputJWT');
        const headerOutput = document.getElementById('headerOutput');
        const payloadOutput = document.getElementById('payloadOutput');
        const signatureOutput = document.getElementById('signatureOutput');

        // Store decoded data
        let decodedData = {
            header: null,
            payload: null,
            signature: null,
            headerRaw: null,
            payloadRaw: null
        };

        // View states
        let headerViewMode = 'json'; // 'json' or 'base64'
        let payloadViewMode = 'json'; // 'json' or 'base64'

        // Initialize message handler
        CodeUtils.Message.init('message');

        // Base64URL decode
        function base64UrlDecode(str) {
            // Replace URL-safe characters
            let base64 = str.replace(/-/g, '+').replace(/_/g, '/');
            // Pad with '=' if necessary
            const pad = base64.length % 4;
            if (pad) {
                base64 += '='.repeat(4 - pad);
            }
            // Decode
            try {
                return decodeURIComponent(atob(base64).split('').map(c => {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
            } catch (e) {
                return atob(base64);
            }
        }

        // Format timestamp
        function formatTimestamp(timestamp) {
            if (!timestamp) return '';
            const date = new Date(timestamp * 1000);
            return date.toLocaleString() + ' (' + date.toISOString() + ')';
        }

        // Check if expired
        function isExpired(exp) {
            if (!exp) return null;
            return Date.now() > exp * 1000;
        }

        // Calculate time difference in human-readable format
        function getTimeDifference(timestamp) {
            const now = Date.now();
            const targetTime = timestamp * 1000;
            const diffMs = Math.abs(targetTime - now);

            const seconds = Math.floor(diffMs / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);

            if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;
            if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''}`;
            if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''}`;
            return `${seconds} second${seconds !== 1 ? 's' : ''}`;
        }

        // Create expiration badge
        function createExpirationBadge(exp) {
            if (!exp) return '';

            const now = Date.now();
            const expTime = exp * 1000;
            const isExpiredNow = now > expTime;
            const timeUntilExpiry = expTime - now;
            const fiveMinutes = 5 * 60 * 1000;

            if (isExpiredNow) {
                const timeAgo = getTimeDifference(exp);
                return `<span class="badge badge-expired">‚úó Expired ${timeAgo} ago</span>`;
            } else if (timeUntilExpiry < fiveMinutes) {
                const timeLeft = getTimeDifference(exp);
                return `<span class="badge badge-expiring">‚ö† Expires in ${timeLeft}</span>`;
            } else {
                const timeLeft = getTimeDifference(exp);
                return `<span class="badge badge-valid">‚úì Valid (${timeLeft} remaining)</span>`;
            }
        }

        // Claim descriptions for tooltips
        const claimDescriptions = {
            'sub': 'Subject - The unique identifier of the user or entity this token represents',
            'iss': 'Issuer - The entity that issued and signed the JWT (e.g., your auth server URL)',
            'aud': 'Audience - The intended recipient(s) of the token (e.g., your application ID)',
            'exp': 'Expiration Time - Unix timestamp when this token expires and should no longer be accepted',
            'iat': 'Issued At - Unix timestamp when this token was created',
            'nbf': 'Not Before - Unix timestamp before which the token should not be accepted',
            'jti': 'JWT ID - Unique identifier for this token, used to prevent replay attacks',
            'scope': 'Scope - Permissions or access levels granted to the bearer of this token',
            'roles': 'Roles - User roles or groups for authorization purposes',
            'email': 'Email - Email address of the user',
            'name': 'Name - Full name of the user',
            'username': 'Username - Username of the user',
            'admin': 'Admin - Whether the user has admin privileges'
        };

        // Create tooltip HTML
        function createTooltip(claim) {
            const description = claimDescriptions[claim];
            if (!description) return '';
            return `<span class="tooltip">?<span class="tooltiptext">${description}</span></span>`;
        }

        // Format claim with tooltip
        function formatClaimWithTooltip(claim, value) {
            const tooltip = createTooltip(claim);
            let formattedValue = value;

            // Format timestamps
            if ((claim === 'exp' || claim === 'iat' || claim === 'nbf') && typeof value === 'number') {
                formattedValue = formatTimestamp(value);
            }

            return `  "${claim}": ${JSON.stringify(value)}${tooltip ? ' ' + tooltip : ''}`;
        }

        // Decode JWT
        function decodeJWT() {
            const token = inputJWT.value.trim();
            if (!token) {
                CodeUtils.Message.error('Please enter a JWT token');
                return;
            }

            const parts = token.split('.');
            if (parts.length !== 3) {
                CodeUtils.Message.error('Invalid JWT format. JWT should have 3 parts separated by dots.');
                return;
            }

            try {
                // Store raw base64 parts
                decodedData.headerRaw = parts[0];
                decodedData.payloadRaw = parts[1];

                // Decode header
                const headerStr = base64UrlDecode(parts[0]);
                decodedData.header = JSON.parse(headerStr);

                // Display header based on current view mode
                if (headerViewMode === 'json') {
                    headerOutput.textContent = JSON.stringify(decodedData.header, null, 2);
                } else {
                    headerOutput.textContent = parts[0];
                }

                // Decode payload
                const payloadStr = base64UrlDecode(parts[1]);
                decodedData.payload = JSON.parse(payloadStr);

                // Format payload with tooltips
                const payloadLines = [];
                payloadLines.push('{');
                const claims = Object.keys(decodedData.payload);
                claims.forEach((claim, index) => {
                    const value = decodedData.payload[claim];
                    const isLast = index === claims.length - 1;
                    const tooltip = createTooltip(claim);
                    let valueStr;

                    // Format timestamps
                    if ((claim === 'exp' || claim === 'iat' || claim === 'nbf') && typeof value === 'number') {
                        valueStr = `${value} (${formatTimestamp(value)})`;
                    } else {
                        valueStr = JSON.stringify(value);
                    }

                    payloadLines.push(`  "${claim}": ${valueStr}${isLast ? '' : ','}`);
                });
                payloadLines.push('}');

                let payloadDisplay = payloadLines.join('\n');

                // Add expiry status with badge
                if (decodedData.payload.exp) {
                    const badge = createExpirationBadge(decodedData.payload.exp);
                    payloadDisplay += '\n\n--- Token Status ---\n';
                    payloadDisplay += 'Expires: ' + formatTimestamp(decodedData.payload.exp);
                }

                if (decodedData.payload.iat) {
                    if (!payloadDisplay.includes('--- Token Status ---')) {
                        payloadDisplay += '\n\n--- Token Status ---\n';
                    } else {
                        payloadDisplay += '\n';
                    }
                    payloadDisplay += 'Issued: ' + formatTimestamp(decodedData.payload.iat);
                }

                // Clear and set payload output
                payloadOutput.innerHTML = '';

                if (payloadViewMode === 'json') {
                    const textNode = document.createTextNode(payloadDisplay);
                    payloadOutput.appendChild(textNode);

                    // Add badge if expiration exists
                    if (decodedData.payload.exp) {
                        const badge = createExpirationBadge(decodedData.payload.exp);
                        const badgeContainer = document.createElement('div');
                        badgeContainer.style.marginTop = 'var(--spacing-sm)';
                        badgeContainer.innerHTML = badge;
                        payloadOutput.appendChild(badgeContainer);
                    }

                    // Add claim explanations for standard claims
                    const standardClaims = Object.keys(decodedData.payload).filter(claim => claimDescriptions[claim]);
                    if (standardClaims.length > 0) {
                        const explanationsContainer = document.createElement('div');
                        explanationsContainer.style.marginTop = 'var(--spacing-md)';
                        explanationsContainer.style.padding = 'var(--spacing-sm)';
                        explanationsContainer.style.background = 'var(--bg-secondary)';
                        explanationsContainer.style.borderRadius = 'var(--radius)';
                        explanationsContainer.style.fontSize = '0.875rem';

                        let explanationsHtml = '<div style="font-weight: 600; margin-bottom: var(--spacing-xs); color: var(--primary);">üìñ Claim Explanations:</div>';
                        standardClaims.forEach(claim => {
                            const value = decodedData.payload[claim];
                            explanationsHtml += `<div style="margin: var(--spacing-xs) 0; padding: var(--spacing-xs); background: var(--bg-primary); border-radius: var(--radius);">`;
                            explanationsHtml += `<strong style="color: var(--primary);">${claim}:</strong> ${claimDescriptions[claim]}`;
                            explanationsHtml += `</div>`;
                        });

                        explanationsContainer.innerHTML = explanationsHtml;
                        payloadOutput.appendChild(explanationsContainer);
                    }
                } else {
                    // Base64 view
                    const textNode = document.createTextNode(parts[1]);
                    payloadOutput.appendChild(textNode);
                }

                // Show signature (cannot decode, just display)
                decodedData.signature = parts[2];
                signatureOutput.textContent = parts[2];

                CodeUtils.Message.success('JWT decoded successfully!');

            } catch (error) {
                CodeUtils.Message.error('Error decoding JWT: ' + error.message);
                headerOutput.textContent = 'Error decoding header';
                payloadOutput.textContent = 'Error decoding payload';
                signatureOutput.textContent = '';
            }
        }

        // Copy section
        async function copySection(section) {
            let content;
            switch (section) {
                case 'header':
                    content = decodedData.header ? JSON.stringify(decodedData.header, null, 2) : '';
                    break;
                case 'payload':
                    content = decodedData.payload ? JSON.stringify(decodedData.payload, null, 2) : '';
                    break;
                case 'signature':
                    content = decodedData.signature || '';
                    break;
            }

            if (!content) {
                CodeUtils.Message.error('Nothing to copy');
                return;
            }

            try {
                await CodeUtils.Clipboard.copy(content);
                CodeUtils.Message.success('Copied to clipboard!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        // Copy all decoded
        async function copyDecoded() {
            if (!decodedData.header || !decodedData.payload) {
                CodeUtils.Message.error('Nothing to copy. Decode a JWT first.');
                return;
            }

            const content = `=== HEADER ===\n${JSON.stringify(decodedData.header, null, 2)}\n\n=== PAYLOAD ===\n${JSON.stringify(decodedData.payload, null, 2)}\n\n=== SIGNATURE ===\n${decodedData.signature}`;

            try {
                await CodeUtils.Clipboard.copy(content);
                CodeUtils.Message.success('Copied to clipboard!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        // Load sample JWT
        function loadSample() {
            // Sample JWT (expired, for demo purposes)
            const sampleJWT = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMiwiZXhwIjoxNTE2MjQyNjIyfQ.POstGetfAytaZS82wHcjoTyoqhMyxXiWdR7Nn7A29DNSl0EiXLdwJ6xC6AfgZWF1bOsS_TuYI3OG85AmiExREkrS6tDfTQ2B3WXlrr-wp5AokiRbz3_oB4OxG-W9KcEEbDRcZc0nH3L7LzYptiy1PtAylQGxHTWZXtGz4ht0bAecBgmpdgXMguEIcoqPJ1n3pIWk_dUZegpqx0Lka21H6XxUTxiy8OcaarA8zdnPUnV6AmNP3ecFawIFYdvJB_cm-GvpCSbr8G8y_Mllj8f4x9nBH8pQux89_6gUY618iYv7tuPWBFfEbLxtF2pZS6YC1aSfLQxeNe8djT9YjpvRZA';
            inputJWT.value = sampleJWT;
            decodeJWT();
        }

        // Clear all
        function clearAll() {
            inputJWT.value = '';
            headerOutput.textContent = 'Decoded header will appear here...';
            payloadOutput.textContent = 'Decoded payload will appear here...';
            signatureOutput.textContent = 'Signature will appear here...';
            decodedData = { header: null, payload: null, signature: null };
            CodeUtils.Message.hide();
        }

        // Token History Management
        const TOKEN_HISTORY_KEY = 'jwt_token_history';
        const MAX_HISTORY_SIZE = 10;

        function getTokenHistory() {
            try {
                const history = localStorage.getItem(TOKEN_HISTORY_KEY);
                return history ? JSON.parse(history) : [];
            } catch (e) {
                return [];
            }
        }

        function saveTokenHistory(history) {
            try {
                localStorage.setItem(TOKEN_HISTORY_KEY, JSON.stringify(history));
            } catch (e) {
                CodeUtils.Message.error('Failed to save token history');
            }
        }

        function updateHistoryDropdown() {
            const history = getTokenHistory();
            const select = document.getElementById('tokenHistorySelect');

            select.innerHTML = `<option value="">üìö Token History (${history.length} saved)</option>`;

            history.forEach((item, index) => {
                const option = document.createElement('option');
                option.value = index;
                const preview = item.token.substring(0, 30) + '...';
                option.textContent = `${item.label} - ${preview}`;
                select.appendChild(option);
            });
        }

        function toggleSaveForm() {
            const form = document.getElementById('saveTokenForm');
            const input = document.getElementById('tokenLabel');
            form.style.display = form.style.display === 'none' ? 'flex' : 'none';
            if (form.style.display === 'flex') {
                input.focus();
            } else {
                input.value = '';
            }
        }

        function saveToken() {
            const token = inputJWT.value.trim();
            const label = document.getElementById('tokenLabel').value.trim();

            if (!token) {
                CodeUtils.Message.error('No token to save');
                return;
            }

            if (!label) {
                CodeUtils.Message.error('Please enter a label for the token');
                return;
            }

            const history = getTokenHistory();

            // Check if already exists
            const existingIndex = history.findIndex(item => item.token === token);
            if (existingIndex !== -1) {
                history[existingIndex].label = label;
                history[existingIndex].timestamp = Date.now();
            } else {
                // Add to beginning
                history.unshift({
                    label: label,
                    token: token,
                    timestamp: Date.now()
                });

                // Keep only MAX_HISTORY_SIZE items
                if (history.length > MAX_HISTORY_SIZE) {
                    history.pop();
                }
            }

            saveTokenHistory(history);
            updateHistoryDropdown();
            toggleSaveForm();
            CodeUtils.Message.success(`Token saved as "${label}"`);
        }

        function loadFromHistory() {
            const select = document.getElementById('tokenHistorySelect');
            const index = parseInt(select.value);

            if (isNaN(index)) return;

            const history = getTokenHistory();
            if (index < 0 || index >= history.length) return;

            inputJWT.value = history[index].token;
            decodeJWT();
            CodeUtils.Message.success(`Loaded token: ${history[index].label}`);
        }

        function clearHistory() {
            if (!confirm('Are you sure you want to clear all saved tokens?')) {
                return;
            }

            localStorage.removeItem(TOKEN_HISTORY_KEY);
            updateHistoryDropdown();
            CodeUtils.Message.success('Token history cleared');
        }

        // Auto-decode functionality
        let decodeTimeout = null;

        function autoDecodeOnInput() {
            const token = inputJWT.value.trim();

            // Clear previous timeout
            if (decodeTimeout) {
                clearTimeout(decodeTimeout);
            }

            // Check if it looks like a JWT (3 parts separated by dots)
            if (token && token.split('.').length === 3) {
                decodeTimeout = setTimeout(() => {
                    decodeJWT();
                }, 500);
            }
        }

        // Signature Verification
        function toggleVerifySection() {
            const content = document.getElementById('verifyContent');
            const icon = document.getElementById('verifyCollapseIcon');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                icon.classList.add('collapsed');
            }
        }

        function updateVerifyKeyInput() {
            const algorithm = document.getElementById('verifyAlgorithm').value;
            const container = document.getElementById('verifyKeyContainer');

            if (algorithm === 'HS256') {
                container.innerHTML = `
                    <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Secret Key</label>
                    <input type="text" id="secretKey" class="editor" placeholder="Enter your HS256 secret key..." style="margin-bottom: var(--spacing-sm);">
                `;
            } else if (algorithm === 'RS256' || algorithm === 'ES256') {
                const algName = algorithm === 'RS256' ? 'RSA' : 'ECDSA P-256';
                container.innerHTML = `
                    <label style="display: block; margin-bottom: var(--spacing-xs); font-weight: 600;">Public Key (PEM format)</label>
                    <textarea id="publicKey" class="editor" placeholder="-----BEGIN PUBLIC KEY-----\n...\n-----END PUBLIC KEY-----" style="min-height: 150px; margin-bottom: var(--spacing-sm); font-size: 0.75rem;"></textarea>
                    <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: calc(var(--spacing-xs) * -1); margin-bottom: var(--spacing-sm);">
                        Enter ${algName} public key in PEM format
                    </p>
                `;
            }
        }

        async function verifySignature() {
            const token = inputJWT.value.trim();
            const algorithm = document.getElementById('verifyAlgorithm').value;
            const resultDiv = document.getElementById('verifyResult');

            if (!token) {
                CodeUtils.Message.error('Please enter a JWT token first');
                return;
            }

            const parts = token.split('.');
            if (parts.length !== 3) {
                CodeUtils.Message.error('Invalid JWT format');
                return;
            }

            try {
                const data = parts[0] + '.' + parts[1];
                const signature = parts[2];
                const encoder = new TextEncoder();

                if (algorithm === 'HS256') {
                    const secret = document.getElementById('secretKey');
                    if (!secret || !secret.value.trim()) {
                        CodeUtils.Message.error('Please enter a secret key');
                        return;
                    }

                    // HMAC-SHA256 verification
                    const keyData = encoder.encode(secret.value.trim());
                    const key = await crypto.subtle.importKey(
                        'raw',
                        keyData,
                        { name: 'HMAC', hash: 'SHA-256' },
                        false,
                        ['sign']
                    );

                    const signatureBuffer = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
                    const signatureArray = new Uint8Array(signatureBuffer);
                    const base64 = btoa(String.fromCharCode(...signatureArray));
                    const base64url = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');

                    if (base64url === signature) {
                        resultDiv.innerHTML = '<div class="verify-result valid">‚úì Signature is valid! Token has not been tampered with.</div>';
                        CodeUtils.Message.success('Signature verified successfully!');
                    } else {
                        resultDiv.innerHTML = '<div class="verify-result invalid">‚úó Invalid signature! Token may have been tampered with or wrong secret key.</div>';
                        CodeUtils.Message.warning('Signature verification failed');
                    }

                } else if (algorithm === 'RS256' || algorithm === 'ES256') {
                    const publicKeyInput = document.getElementById('publicKey');
                    if (!publicKeyInput || !publicKeyInput.value.trim()) {
                        CodeUtils.Message.error('Please enter a public key');
                        return;
                    }

                    // Parse PEM public key
                    const pemKey = publicKeyInput.value.trim();
                    const pemContents = pemKey
                        .replace(/-----BEGIN PUBLIC KEY-----/, '')
                        .replace(/-----END PUBLIC KEY-----/, '')
                        .replace(/\s/g, '');
                    const binaryKey = atob(pemContents);
                    const keyData = new Uint8Array(binaryKey.length);
                    for (let i = 0; i < binaryKey.length; i++) {
                        keyData[i] = binaryKey.charCodeAt(i);
                    }

                    // Import public key
                    const keyAlgorithm = algorithm === 'RS256'
                        ? { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-256' }
                        : { name: 'ECDSA', namedCurve: 'P-256' };

                    const key = await crypto.subtle.importKey(
                        'spki',
                        keyData,
                        keyAlgorithm,
                        false,
                        ['verify']
                    );

                    // Convert signature from base64url to ArrayBuffer
                    const sigPadded = signature.replace(/-/g, '+').replace(/_/g, '/');
                    const pad = sigPadded.length % 4;
                    const sigBase64 = sigPadded + (pad ? '='.repeat(4 - pad) : '');
                    const sigBinary = atob(sigBase64);
                    const sigArray = new Uint8Array(sigBinary.length);
                    for (let i = 0; i < sigBinary.length; i++) {
                        sigArray[i] = sigBinary.charCodeAt(i);
                    }

                    // Verify signature
                    const verifyAlgorithm = algorithm === 'RS256'
                        ? 'RSASSA-PKCS1-v1_5'
                        : { name: 'ECDSA', hash: 'SHA-256' };

                    const isValid = await crypto.subtle.verify(
                        verifyAlgorithm,
                        key,
                        sigArray,
                        encoder.encode(data)
                    );

                    if (isValid) {
                        resultDiv.innerHTML = '<div class="verify-result valid">‚úì Signature is valid! Token has not been tampered with.</div>';
                        CodeUtils.Message.success('Signature verified successfully!');
                    } else {
                        resultDiv.innerHTML = '<div class="verify-result invalid">‚úó Invalid signature! Token may have been tampered with or wrong public key.</div>';
                        CodeUtils.Message.warning('Signature verification failed');
                    }
                }

            } catch (error) {
                resultDiv.innerHTML = '<div class="verify-result invalid">‚úó Verification error: ' + error.message + '</div>';
                CodeUtils.Message.error('Verification failed: ' + error.message);
            }
        }

        // JWT Generation
        function toggleGenerateSection() {
            const content = document.getElementById('generateContent');
            const icon = document.getElementById('generateCollapseIcon');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                icon.classList.add('collapsed');
            }
        }

        function updateGenerateKeyInput() {
            const algorithm = document.getElementById('generateAlgorithm').value;
            const container = document.getElementById('generateKeyContainer');

            if (algorithm === 'none') {
                container.style.display = 'none';
            } else if (algorithm === 'HS256') {
                container.style.display = 'block';
            }
        }

        function loadGenerateExample() {
            const currentTime = Math.floor(Date.now() / 1000);
            const expiryTime = currentTime + 3600; // 1 hour from now

            document.getElementById('generateHeader').value = JSON.stringify({
                "alg": "HS256",
                "typ": "JWT"
            }, null, 2);

            document.getElementById('generatePayload').value = JSON.stringify({
                "sub": "1234567890",
                "name": "John Doe",
                "iat": currentTime,
                "exp": expiryTime
            }, null, 2);

            document.getElementById('generateAlgorithm').value = 'HS256';
            updateGenerateKeyInput();
            document.getElementById('generateSecretKey').value = 'your-256-bit-secret';

            CodeUtils.Message.success('Example loaded! Modify and click Generate JWT.');
        }

        async function generateJWT() {
            const headerInput = document.getElementById('generateHeader').value.trim();
            const payloadInput = document.getElementById('generatePayload').value.trim();
            const algorithm = document.getElementById('generateAlgorithm').value;
            const resultDiv = document.getElementById('generateResult');

            if (!headerInput || !payloadInput) {
                CodeUtils.Message.error('Please enter both header and payload JSON');
                return;
            }

            try {
                // Parse and validate JSON
                const header = JSON.parse(headerInput);
                const payload = JSON.parse(payloadInput);

                // Base64URL encode
                const base64urlEncode = (obj) => {
                    const json = JSON.stringify(obj);
                    const base64 = btoa(unescape(encodeURIComponent(json)));
                    return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
                };

                const headerEncoded = base64urlEncode(header);
                const payloadEncoded = base64urlEncode(payload);

                let jwt;

                if (algorithm === 'none') {
                    // Unsigned JWT
                    jwt = headerEncoded + '.' + payloadEncoded + '.';

                    resultDiv.innerHTML = `
                        <div style="margin-top: var(--spacing-sm); padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--radius); border: 1px solid var(--border);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-xs);">
                                <strong style="color: var(--primary);">Generated JWT (Unsigned)</strong>
                                <button class="btn btn-sm" onclick="copyGeneratedJWT()">Copy JWT</button>
                            </div>
                            <textarea id="generatedJWT" readonly class="editor" style="min-height: 100px; font-size: 0.75rem; background: var(--bg-primary);">${jwt}</textarea>
                            <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: var(--spacing-xs); margin-bottom: 0;">
                                ‚ö†Ô∏è This JWT is unsigned. Most servers will reject unsigned tokens.
                            </p>
                        </div>
                    `;

                } else if (algorithm === 'HS256') {
                    const secretKey = document.getElementById('generateSecretKey').value.trim();
                    if (!secretKey) {
                        CodeUtils.Message.error('Please enter a secret key for HS256');
                        return;
                    }

                    // Sign with HMAC-SHA256
                    const data = headerEncoded + '.' + payloadEncoded;
                    const encoder = new TextEncoder();
                    const keyData = encoder.encode(secretKey);
                    const key = await crypto.subtle.importKey(
                        'raw',
                        keyData,
                        { name: 'HMAC', hash: 'SHA-256' },
                        false,
                        ['sign']
                    );

                    const signatureBuffer = await crypto.subtle.sign('HMAC', key, encoder.encode(data));
                    const signatureArray = new Uint8Array(signatureBuffer);
                    const base64 = btoa(String.fromCharCode(...signatureArray));
                    const signature = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');

                    jwt = data + '.' + signature;

                    resultDiv.innerHTML = `
                        <div style="margin-top: var(--spacing-sm); padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--radius); border: 1px solid var(--border);">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--spacing-xs);">
                                <strong style="color: var(--primary);">Generated JWT (HS256 Signed)</strong>
                                <div>
                                    <button class="btn btn-sm btn-secondary" onclick="loadGeneratedJWT()">Load & Decode</button>
                                    <button class="btn btn-sm" onclick="copyGeneratedJWT()">Copy JWT</button>
                                </div>
                            </div>
                            <textarea id="generatedJWT" readonly class="editor" style="min-height: 100px; font-size: 0.75rem; background: var(--bg-primary);">${jwt}</textarea>
                            <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: var(--spacing-xs); margin-bottom: 0;">
                                ‚úì JWT signed with HS256. You can verify it using the same secret key.
                            </p>
                        </div>
                    `;
                }

                CodeUtils.Message.success('JWT generated successfully!');

            } catch (error) {
                resultDiv.innerHTML = '';
                CodeUtils.Message.error('Generation error: ' + error.message);
            }
        }

        async function copyGeneratedJWT() {
            const jwtElement = document.getElementById('generatedJWT');
            if (!jwtElement) {
                CodeUtils.Message.error('No JWT to copy');
                return;
            }

            try {
                await CodeUtils.Clipboard.copy(jwtElement.value);
                CodeUtils.Message.success('JWT copied to clipboard!');
            } catch (err) {
                CodeUtils.Message.error(err.message);
            }
        }

        function loadGeneratedJWT() {
            const jwtElement = document.getElementById('generatedJWT');
            if (!jwtElement) {
                CodeUtils.Message.error('No JWT to load');
                return;
            }

            inputJWT.value = jwtElement.value;
            decodeJWT();
            CodeUtils.Message.success('Generated JWT loaded for decoding!');

            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        // Token Comparison
        function toggleCompareSection() {
            const content = document.getElementById('compareContent');
            const icon = document.getElementById('compareCollapseIcon');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.classList.remove('collapsed');
            } else {
                content.style.display = 'none';
                icon.classList.add('collapsed');
            }
        }

        function loadCurrentToken() {
            const token = inputJWT.value.trim();
            if (!token) {
                CodeUtils.Message.error('No token loaded in main input');
                return;
            }

            document.getElementById('compareToken1').value = token;
            CodeUtils.Message.success('Current token loaded as Token 1');
        }

        function compareTokens() {
            const token1 = document.getElementById('compareToken1').value.trim();
            const token2 = document.getElementById('compareToken2').value.trim();
            const resultDiv = document.getElementById('compareResult');

            if (!token1 || !token2) {
                CodeUtils.Message.error('Please enter both tokens to compare');
                return;
            }

            const parts1 = token1.split('.');
            const parts2 = token2.split('.');

            if (parts1.length !== 3 || parts2.length !== 3) {
                CodeUtils.Message.error('Invalid JWT format in one or both tokens');
                return;
            }

            try {
                // Decode both tokens
                const header1 = JSON.parse(base64UrlDecode(parts1[0]));
                const payload1 = JSON.parse(base64UrlDecode(parts1[1]));
                const signature1 = parts1[2];

                const header2 = JSON.parse(base64UrlDecode(parts2[0]));
                const payload2 = JSON.parse(base64UrlDecode(parts2[1]));
                const signature2 = parts2[2];

                // Compare headers
                const headerDiff = compareObjects(header1, header2, 'Header');

                // Compare payloads
                const payloadDiff = compareObjects(payload1, payload2, 'Payload');

                // Compare signatures
                const signatureDiff = signature1 === signature2
                    ? '<div class="diff-item diff-same">üîí Signatures are identical</div>'
                    : '<div class="diff-item diff-changed">üîí Signatures are different</div>';

                // Build result HTML
                resultDiv.innerHTML = `
                    <div class="diff-container">
                        <div class="diff-section">
                            <h4>Token 1</h4>
                            ${headerDiff.token1}
                            ${payloadDiff.token1}
                            ${signatureDiff}
                        </div>
                        <div class="diff-section">
                            <h4>Token 2</h4>
                            ${headerDiff.token2}
                            ${payloadDiff.token2}
                            ${signatureDiff}
                        </div>
                    </div>
                    <div style="margin-top: var(--spacing-md); padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--radius); border: 1px solid var(--border);">
                        <h4 style="margin-top: 0; margin-bottom: var(--spacing-sm); color: var(--primary);">Legend</h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: var(--spacing-xs); font-size: 0.875rem;">
                            <div><span style="color: #28a745;">üü¢ Added</span> - Present in Token 2 only</div>
                            <div><span style="color: #dc3545;">üî¥ Removed</span> - Present in Token 1 only</div>
                            <div><span style="color: #ffc107;">üü° Changed</span> - Different values</div>
                            <div><span style="color: var(--text-secondary);">‚ö™ Same</span> - Identical in both</div>
                        </div>
                    </div>
                `;

                CodeUtils.Message.success('Tokens compared successfully!');

            } catch (error) {
                resultDiv.innerHTML = '';
                CodeUtils.Message.error('Comparison error: ' + error.message);
            }
        }

        function compareObjects(obj1, obj2, sectionName) {
            const keys1 = Object.keys(obj1);
            const keys2 = Object.keys(obj2);
            const allKeys = [...new Set([...keys1, ...keys2])].sort();

            let html1 = `<div style="margin-bottom: var(--spacing-sm);"><strong>${sectionName}:</strong></div>`;
            let html2 = `<div style="margin-bottom: var(--spacing-sm);"><strong>${sectionName}:</strong></div>`;

            allKeys.forEach(key => {
                const inObj1 = key in obj1;
                const inObj2 = key in obj2;

                if (inObj1 && inObj2) {
                    const val1 = JSON.stringify(obj1[key]);
                    const val2 = JSON.stringify(obj2[key]);

                    if (val1 === val2) {
                        // Same value
                        html1 += `<div class="diff-item diff-same">${key}: ${val1}</div>`;
                        html2 += `<div class="diff-item diff-same">${key}: ${val2}</div>`;
                    } else {
                        // Changed value
                        html1 += `<div class="diff-item diff-changed">üü° ${key}: ${val1}</div>`;
                        html2 += `<div class="diff-item diff-changed">üü° ${key}: ${val2}</div>`;
                    }
                } else if (inObj1) {
                    // Only in obj1 (removed in obj2)
                    html1 += `<div class="diff-item diff-removed">üî¥ ${key}: ${JSON.stringify(obj1[key])}</div>`;
                    html2 += `<div class="diff-item diff-added" style="opacity: 0.3;">${key}: (not present)</div>`;
                } else {
                    // Only in obj2 (added in obj2)
                    html1 += `<div class="diff-item diff-removed" style="opacity: 0.3;">${key}: (not present)</div>`;
                    html2 += `<div class="diff-item diff-added">üü¢ ${key}: ${JSON.stringify(obj2[key])}</div>`;
                }
            });

            return { token1: html1, token2: html2 };
        }

        // Base64 View Toggle
        function toggleHeaderView() {
            if (!decodedData.header) {
                CodeUtils.Message.error('Please decode a JWT first');
                return;
            }

            const toggleBtn = document.getElementById('headerViewToggle');
            const headerOutput = document.getElementById('headerOutput');

            if (headerViewMode === 'json') {
                // Switch to base64
                headerViewMode = 'base64';
                headerOutput.textContent = decodedData.headerRaw;
                toggleBtn.textContent = 'JSON';
                CodeUtils.Message.success('Showing raw base64url-encoded header');
            } else {
                // Switch to JSON
                headerViewMode = 'json';
                headerOutput.textContent = JSON.stringify(decodedData.header, null, 2);
                toggleBtn.textContent = 'Base64';
                CodeUtils.Message.success('Showing decoded JSON header');
            }
        }

        function togglePayloadView() {
            if (!decodedData.payload) {
                CodeUtils.Message.error('Please decode a JWT first');
                return;
            }

            const toggleBtn = document.getElementById('payloadViewToggle');
            const payloadOutput = document.getElementById('payloadOutput');

            if (payloadViewMode === 'json') {
                // Switch to base64
                payloadViewMode = 'base64';
                payloadOutput.textContent = decodedData.payloadRaw;
                toggleBtn.textContent = 'JSON';
                CodeUtils.Message.success('Showing raw base64url-encoded payload');
            } else {
                // Switch to JSON - re-decode to get all features
                payloadViewMode = 'json';
                decodeJWT();
                toggleBtn.textContent = 'Base64';
                CodeUtils.Message.success('Showing decoded JSON payload');
            }
        }

        // Initialize
        updateHistoryDropdown();

        // Keyboard shortcuts
        CodeUtils.Shortcuts.register('Enter', decodeJWT, true);
        CodeUtils.Shortcuts.register('k', copyDecoded, true);

        // Auto-decode on paste
        inputJWT.addEventListener('paste', () => {
            setTimeout(decodeJWT, 100);
        });

        // Auto-decode on input (debounced)
        inputJWT.addEventListener('input', autoDecodeOnInput);

        // Allow Enter key in save token label input
        document.getElementById('tokenLabel').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveToken();
            }
        });
    </script>
</body>
</html>
